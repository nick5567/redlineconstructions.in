"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.serverEntryVirtualId = void 0;
exports.serverProductionEntryPlugin = serverProductionEntryPlugin;
const utils_js_1 = require("./utils.js");
const path_1 = __importDefault(require("path"));
const fs_1 = require("fs");
const serverEntryFileNameBase_js_1 = require("../shared/serverEntryFileNameBase.js");
const debugLogsBuildTime_js_1 = require("./debugLogsBuildTime.js");
const url_1 = require("url");
const module_1 = require("module");
const importMetaUrl = 
// @ts-ignore import.meta is shimmed at dist/cjs by dist-cjs-fixup.js
`file://${__filename}` +
    // trick to avoid `@vercel/ncc` to glob import
    (() => '')();
const __dirname_ = (0, utils_js_1.toPosixPath)(path_1.default.dirname((0, url_1.fileURLToPath)(importMetaUrl)));
const isCJS = 'require.resolve' === 'require.resolve'; // see dist-cjs-fixup.js
const exportStatement = isCJS ? 'exports.' : 'export const ';
const require_ = (0, module_1.createRequire)(importMetaUrl);
const autoImporterFilePath = (0, utils_js_1.toPosixPath)(require_.resolve('../runtime/autoImporter.js'));
const serverEntryVirtualId = 'virtual:@brillout/vite-plugin-server-entry:serverEntry';
exports.serverEntryVirtualId = serverEntryVirtualId;
// https://vitejs.dev/guide/api-plugin.html#virtual-modules-convention
const virtualIdPrefix = '\0';
// Using the semver major to determine compatible versions is a much inferior solution. Because, for example, when the user updates Vike > @brillout/vite-plugin-server-entry from version 0.4.8 (`apiVersion===4`) to 0.4.10 (`apiVersion===5`) then things just works because Telefunc > @brillout/vite-plugin-server-entry also updates to `0.4.10`. On the other hand, when the user updates Vike > @brillout/vite-plugin-server-entry to 0.5.0 then this won't update Telefunc > @brillout/vite-plugin-server-entry which is stuck to 0.4.x and the user is forced to update Telefunc.
const apiVersion = 5;
/**
 * This plugin does two things:
 *  - Generates a "server entry" file at `dist/server/entry.js`.
 *  - Generates a "auto importer" file at `node_modules/@brillout/vite-plugin-server-entry/dist/runtime/autoImporter.js`.
 *
 * See https://github.com/brillout/vite-plugin-server-entry#what-it-does for more information.
 */
function serverProductionEntryPlugin(pluginConfigProvidedByLibrary) {
    const pluginName = `@brillout/vite-plugin-server-entry:${pluginConfigProvidedByLibrary.libraryName.toLowerCase()}`;
    let config;
    let library;
    let skip;
    return [
        {
            name: pluginName,
            apply: 'build',
            // We need to run this plugin after other plugin instances, so that assertApiVersions() works also for libraries using older plugin versions
            enforce: 'post',
            configResolved() {
                if (skip)
                    return;
                if (!isLeaderPluginInstance(config, library)) {
                    skip = true;
                    return;
                }
                assertApiVersions(config, pluginConfigProvidedByLibrary.libraryName);
                applyPluginConfigProvidedByUser(config);
                if (!config._vitePluginServerEntry.disableServerEntryEmit) {
                    const serverEntryName = getServerEntryName(config);
                    config.build.rollupOptions.input = (0, utils_js_1.injectRollupInputs)({ [serverEntryName]: serverEntryVirtualId }, config);
                }
            },
            buildStart() {
                if (skip)
                    return;
                clearAutoImporter(config);
            },
            resolveId(id) {
                if (skip)
                    return;
                if (id === serverEntryVirtualId) {
                    return virtualIdPrefix + serverEntryVirtualId;
                }
            },
            load(id) {
                if (skip)
                    return;
                (0, utils_js_1.assert)(id !== serverEntryVirtualId);
                if (id === virtualIdPrefix + serverEntryVirtualId) {
                    const serverProductionEntry = getServerProductionEntryAll(config);
                    return serverProductionEntry;
                }
            },
            generateBundle(_rollupOptions, bundle) {
                if (skip)
                    return;
                // Write node_modules/@brillout/vite-plugin-server-entry/dist/autoImporter.js
                if (!isAutoImportDisabled(config)) {
                    const entry = findServerEntry(bundle, config.build.outDir);
                    (0, utils_js_1.assert)(entry);
                    const entryFileName = entry.fileName;
                    if (!entryFileName)
                        (0, utils_js_1.assert)(false, { entry });
                    setAutoImporter(config, entryFileName);
                }
                else {
                    (0, debugLogsBuildTime_js_1.debugLogsBuildtime)({ disabled: true, paths: null });
                }
            },
        },
        {
            name: `${pluginName}:config`,
            apply: 'build',
            // We need to run this plugin before in order to make isLeaderPluginInstance() work
            enforce: 'pre',
            configResolved(configUnresolved) {
                // Upon the server-side build (`$ vite build --ssr`), we need to override the previous `skip` value set by the client-side build (`$ vite build`).
                skip = !(0, utils_js_1.viteIsSSR)(configUnresolved);
                if (skip)
                    return;
                (0, utils_js_1.assertUsage)(typeof configUnresolved.build.ssr !== 'string', "Setting the server build entry over the Vite configuration `build.ssr` (i.e. `--ssr path/to/entry.js`) isn't supported (because of a Vite bug), see workaround at https://github.com/brillout/vite-plugin-server-entry/issues/9#issuecomment-2027641624");
                const resolved = resolveConfig(configUnresolved, pluginConfigProvidedByLibrary);
                config = resolved.config;
                library = resolved.library;
            },
        },
    ];
}
function resolveConfig(configUnresolved, pluginConfigProvidedByLibrary) {
    (0, utils_js_1.assert)((0, utils_js_1.viteIsSSR)(configUnresolved));
    const pluginConfigResolved = configUnresolved._vitePluginServerEntry ?? {
        libraries: [],
        apiVersion,
        inject: false,
        disableAutoImport: false,
        disableServerEntryEmit: false,
    };
    const library = {
        getServerProductionEntry: pluginConfigProvidedByLibrary.getServerProductionEntry,
        libraryName: pluginConfigProvidedByLibrary.libraryName,
        pluginVersion: utils_js_1.projectInfo.projectVersion,
        apiVersion,
    };
    pluginConfigResolved.libraries.push(library);
    (0, utils_js_1.objectAssign)(configUnresolved, {
        _vitePluginServerEntry: pluginConfigResolved,
    });
    const config = configUnresolved;
    return { config, library };
}
function applyPluginConfigProvidedByUser(config) {
    const pluginConfigResolved = config._vitePluginServerEntry;
    const pluginConfigProvidedByUser = config.vitePluginServerEntry ?? {};
    if (pluginConfigProvidedByUser.inject !== undefined) {
        pluginConfigResolved.inject = pluginConfigProvidedByUser.inject;
    }
    if (pluginConfigProvidedByUser.disableAutoImport !== undefined) {
        pluginConfigResolved.disableAutoImport = pluginConfigProvidedByUser.disableAutoImport;
    }
    if (pluginConfigProvidedByUser.disableServerEntryEmit !== undefined) {
        pluginConfigResolved.disableServerEntryEmit = pluginConfigProvidedByUser.disableServerEntryEmit;
    }
}
function isLeaderPluginInstance(config, library) {
    const { libraries } = config._vitePluginServerEntry;
    const pluginVersionCurrent = utils_js_1.projectInfo.projectVersion;
    (0, utils_js_1.assert)(libraries.includes(library));
    const isNotUsingNewestPluginVersion = libraries.some((lib) => {
        // Can be undefined when set by an older @brillout/vite-plugin-dist-importer version
        if (!lib.pluginVersion)
            return false;
        return isHigherVersion(lib.pluginVersion, pluginVersionCurrent);
    });
    if (isNotUsingNewestPluginVersion)
        return false;
    const librariesUsingNewestPluginVersion = libraries.filter((lib) => lib.pluginVersion === pluginVersionCurrent);
    return librariesUsingNewestPluginVersion[0] === library;
}
function getServerProductionEntryAll(config) {
    (0, utils_js_1.assert)((0, utils_js_1.viteIsSSR)(config));
    const serverProductionEntry = [
        '// Generated by https://github.com/brillout/vite-plugin-server-entry',
        ...config._vitePluginServerEntry.libraries.map((library) => {
            // Should be true because of assertApiVersions()
            (0, utils_js_1.assert)(getLibraryApiVersion(library) === apiVersion);
            const entryCode = (library.getServerProductionEntry ??
                // Support old `getServerProductionEntry()` name: it was previously called `getImporterCode()`.
                // TODO/api-version-bump: We'll be able to remove this next time we bump `apiVersion`.
                // @ts-expect-error
                library.getImporterCode)();
            return entryCode;
        }),
    ].join('\n');
    return serverProductionEntry;
}
function setAutoImporter(config, entryFileName) {
    const { distServerPathRelative, distServerPathAbsolute } = getDistServerPathRelative(config);
    const serverEntryFilePathRelative = path_1.default.posix.join(distServerPathRelative, entryFileName);
    const serverEntryFilePathAbsolute = path_1.default.posix.join(distServerPathAbsolute, entryFileName);
    const { root } = config;
    (0, utils_js_1.assertPosixPath)(root);
    (0, utils_js_1.assert)(!isAutoImportDisabled(config));
    (0, utils_js_1.assert)(!(0, utils_js_1.isYarnPnP)());
    writeAutoImporterFile((autoImporterFilePathResolved) => [
        `${exportStatement}status = 'SET';`,
        `${exportStatement}pluginVersion = ${JSON.stringify(utils_js_1.projectInfo.projectVersion)};`,
        `${exportStatement}loadServerEntry = async () => { await import(${JSON.stringify(serverEntryFilePathRelative)}); };`,
        `${exportStatement}paths = {`,
        `  autoImporterFilePathOriginal: ${JSON.stringify(autoImporterFilePathResolved)},`,
        '  autoImporterFilePathActual: (() => { try { return `file://${__filename}` } catch { return null } })(),',
        `  serverEntryFilePathRelative: ${JSON.stringify(serverEntryFilePathRelative)},`,
        `  serverEntryFilePathOriginal: ${JSON.stringify(serverEntryFilePathAbsolute)},`,
        `  serverEntryFilePathResolved: () => require.resolve(${JSON.stringify(serverEntryFilePathRelative)}),`,
        '};',
        '',
    ].join('\n'));
}
function clearAutoImporter(config) {
    if (isAutoImportDisabled(config)) {
        return;
    }
    (0, utils_js_1.assert)(!(0, utils_js_1.isYarnPnP)());
    const status = 'BUILDING';
    writeAutoImporterFile(() => [`${exportStatement}status = '${status}';`, ''].join('\n'));
}
/** Is `semver1` higher than `semver2`?*/
function isHigherVersion(semver1, semver2) {
    const parsed1 = parseSemver(semver1);
    const parsed2 = parseSemver(semver2);
    for (let i = 0; i <= parsed1.parts.length - 1; i++) {
        if (parsed1.parts[i] !== parsed2.parts[i]) {
            return parsed1.parts[i] > parsed2.parts[i];
        }
    }
    if (parsed1.isPreRelease !== parsed2.isPreRelease) {
        return parsed1.isPreRelease;
    }
    return false;
}
function parseSemver(semver) {
    let isPreRelease = false;
    if (semver.includes('-')) {
        isPreRelease = true;
        semver = semver.split('-')[0]; // '0.2.16-commit-89bbe89' => '0.2.16'
    }
    (0, utils_js_1.assert)(/^[0-9\.]+$/.test(semver));
    const partsStr = semver.split('.');
    (0, utils_js_1.assert)(partsStr.length === 3);
    const parts = partsStr.map((n) => parseInt(n, 10));
    return { parts, isPreRelease };
}
function getDistServerPathRelative(config) {
    (0, utils_js_1.assert)((0, utils_js_1.viteIsSSR)(config));
    const { root } = config;
    const importerDir = __dirname_;
    (0, utils_js_1.assertPosixPath)(importerDir);
    (0, utils_js_1.assert)((0, utils_js_1.isAbsolutePath)(importerDir));
    (0, utils_js_1.assertPosixPath)(root);
    (0, utils_js_1.assert)((0, utils_js_1.isAbsolutePath)(root));
    const rootRelative = path_1.default.posix.relative(importerDir, root); // To `require()` an absolute path doesn't seem to work on Vercel
    let { outDir } = config.build;
    // SvelteKit doesn't set config.build.outDir to a posix path
    outDir = (0, utils_js_1.toPosixPath)(outDir);
    if ((0, utils_js_1.isAbsolutePath)(outDir)) {
        outDir = path_1.default.posix.relative(root, outDir);
        (0, utils_js_1.assert)(!(0, utils_js_1.isAbsolutePath)(outDir));
    }
    const distServerPathRelative = path_1.default.posix.join(rootRelative, outDir);
    const distServerPathAbsolute = path_1.default.posix.join(root, outDir);
    (0, debugLogsBuildTime_js_1.debugLogsBuildtime)({
        disabled: false,
        paths: { importerDir, root, rootRelative, outDir, distServerPathRelative, distServerPathAbsolute },
    });
    return { distServerPathRelative, distServerPathAbsolute };
}
function assertApiVersions(config, currentLibraryName) {
    const librariesNeedingUpdate = [];
    ['vitePluginDistImporter', '_vitePluginImportBuild'].forEach((key) => {
        if (key in config) {
            const dataOld = config[key];
            dataOld.libraries.forEach((lib) => {
                (0, utils_js_1.assert)(lib.libraryName);
                librariesNeedingUpdate.push(lib.libraryName);
            });
        }
    });
    const pluginConfigResolved = config._vitePluginServerEntry;
    pluginConfigResolved.libraries.forEach((library) => {
        const apiVersionLib = getLibraryApiVersion(library);
        if (apiVersionLib < apiVersion) {
            librariesNeedingUpdate.push(library.libraryName);
        }
        else {
            // Should be true thanks to isLeaderPluginInstance()
            (0, utils_js_1.assert)(apiVersionLib === apiVersion);
        }
    });
    if (librariesNeedingUpdate.length > 0) {
        const libs = (0, utils_js_1.joinEnglish)(librariesNeedingUpdate, 'and');
        // We purposely use `throw new Error()` instead of `assertUsage()`, in order to not confuse the user with superfluous information
        throw new Error(`Update ${libs} to its latest version and try again: ${currentLibraryName} requires a newer version of ${libs}.`);
    }
}
function getLibraryApiVersion(library) {
    // library.apiVersion can be undefined when set by an older @brillout/vite-plugin-server-entry version
    const apiVersionLib = library.apiVersion ?? 1;
    return apiVersionLib;
}
function findServerEntry(bundle, outDir) {
    const entry = (0, utils_js_1.findRollupBundleEntry)(serverEntryFileNameBase_js_1.serverEntryFileNameBaseAlternative, bundle, outDir) ||
        (0, utils_js_1.findRollupBundleEntry)(serverEntryFileNameBase_js_1.serverEntryFileNameBase, bundle, outDir);
    (0, utils_js_1.assertUsage)(entry, errMsgEntryRemoved([
        //
        serverEntryFileNameBase_js_1.serverEntryFileNameBase,
        serverEntryFileNameBase_js_1.serverEntryFileNameBaseAlternative,
    ], Object.keys(bundle), Object.values(bundle)
        .map((entry) => entry.name)
        .filter(utils_js_1.isNotNullish)));
    return entry;
}
function errMsgEntryRemoved(entriesMissing, entryKeys, entryNames) {
    const list = (items) => '[' + items.map((e) => `'${e}'`).join(', ') + ']';
    return [
        entriesMissing.length === 1
            ? `Cannot find build server entry '${entriesMissing[0]}'.`
            : `Cannot find build server entry, searching for:  ${list(entriesMissing)} (none of them exist, but one of these should exist).`,
        `Make sure your Vite config (or that of a Vite plugin) doesn't remove/overwrite server build entries.`,
        `(Found entry names: ${list(entryNames)}, found entry keys: ${list(entryKeys)}.)`,
    ].join(' ');
}
function isAutoImportDisabled(config) {
    const { disableAutoImport } = config._vitePluginServerEntry;
    return (0, utils_js_1.isYarnPnP)() || disableAutoImport;
}
function getServerEntryName(config) {
    const entries = (0, utils_js_1.normalizeRollupInput)(config.build.rollupOptions.input);
    (0, utils_js_1.assert)(entries[serverEntryFileNameBase_js_1.serverEntryFileNameBase] !== serverEntryVirtualId &&
        entries[serverEntryFileNameBase_js_1.serverEntryFileNameBaseAlternative] !== serverEntryVirtualId);
    const serverEntryName = !entries[serverEntryFileNameBase_js_1.serverEntryFileNameBase]
        ? serverEntryFileNameBase_js_1.serverEntryFileNameBase
        : serverEntryFileNameBase_js_1.serverEntryFileNameBaseAlternative;
    (0, utils_js_1.assert)(!entries[serverEntryName]);
    return serverEntryName;
}
function writeAutoImporterFile(fileContent) {
    (0, utils_js_1.assertPosixPath)(autoImporterFilePath);
    (0, utils_js_1.assert)((autoImporterFilePath.split('/dist/esm/').length === 2 && autoImporterFilePath.split('/dist/cjs/').length === 1) ||
        (autoImporterFilePath.split('/dist/esm/').length === 1 && autoImporterFilePath.split('/dist/cjs/').length === 2));
    const autoImporterFilePathEsm = autoImporterFilePath.replace('/dist/cjs/', '/dist/esm/');
    const autoImporterFilePathCjs = autoImporterFilePath.replace('/dist/esm/', '/dist/cjs/');
    [autoImporterFilePathEsm, autoImporterFilePathCjs].forEach((autoImporterFilePathResolved) => {
        (0, fs_1.writeFileSync)(autoImporterFilePathResolved, fileContent(autoImporterFilePathResolved));
    });
}
