"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.importServerProductionEntry = importServerProductionEntry;
exports.importServerProductionIndex = importServerProductionIndex;
const utils_js_1 = require("./utils.js");
const debugLogsRuntime_js_1 = require("./debugLogsRuntime.js");
const debug_js_1 = require("../shared/debug.js");
const serverEntryFileNameBase_js_1 = require("../shared/serverEntryFileNameBase.js");
const crawlOutDir_js_1 = require("./crawlOutDir.js");
const import_1 = require("@brillout/import");
const wrongUsageNotBuilt = 'The server production entry is missing. (Re-)build your app and try again. If you still get this error, then you need to manually import the server production entry, see https://github.com/brillout/vite-plugin-server-entry#manual-import';
/** To be used only for `$ vike preview`. */
async function importServerProductionIndex(args) {
    // We don't need autoImporter â€” we can just crawl dist/server/index.mjs as we have both `outDir` and `node:fs`. Because `$ vike preview` isn't supposed to be called in edge environments, we can load Node.js as well as Vite (thus we know `outDir`).
    const outFilePath = await (0, crawlOutDir_js_1.crawlOutDir)({
        ...args,
        outFileSearch: [serverEntryFileNameBase_js_1.serverIndexFileNameBase],
    });
    (0, utils_js_1.assertUsage)(outFilePath, wrongUsageNotBuilt);
    await (0, import_1.import_)(outFilePath);
    return { outServerIndex: outFilePath };
}
async function importServerProductionEntry(args = {}) {
    const autoImporter = (await Promise.resolve().then(() => __importStar(require('./autoImporter.js'))));
    (0, debugLogsRuntime_js_1.debugLogsRuntimePre)(autoImporter);
    let success = false;
    let requireError;
    let isOutsideOfCwd = null;
    if (autoImporter.status === 'SET') {
        // In a monorepo the autoImporter can be that of another project => don't use autoImporter if it's that case
        isOutsideOfCwd = isServerEntryOutsideOfCwd(autoImporter.paths);
        if (isOutsideOfCwd === false || isOutsideOfCwd === null) {
            try {
                await autoImporter.loadServerEntry();
                success = true;
            }
            catch (err) {
                if (!debug_js_1.isDebug) {
                    throw err;
                }
                else {
                    requireError = err;
                }
            }
        }
    }
    if (!success) {
        const outFilePath = await (0, crawlOutDir_js_1.crawlOutDir)({
            ...args,
            outFileSearch: [serverEntryFileNameBase_js_1.serverEntryFileNameBase, serverEntryFileNameBase_js_1.serverEntryFileNameBaseAlternative],
        });
        if (outFilePath) {
            await (0, import_1.import_)(outFilePath);
            success = true;
        }
    }
    // We don't handle the following case:
    //  - When the user directly imports dist/server/entry.js because we assume that Vike and Telefunc don't call importServerProductionEntry() in that case
    (0, debugLogsRuntime_js_1.debugLogsRuntimePost)({ success, requireError, isOutsideOfCwd, ...args });
    if (args.tolerateDoesNotExist) {
        return success;
    }
    else {
        (0, utils_js_1.assertUsage)(success, wrongUsageNotBuilt);
        return null;
    }
}
// dist/server/entry.js may not belong to process.cwd() if e.g. Vike is linked => autoImporter.js can potentially be shared between multiple projects
function isServerEntryOutsideOfCwd(paths) {
    const cwd = (0, utils_js_1.getCwdSafe)();
    // We cannot check edge environments. Upon edge deployment the server code is usually bundled right after `$ vite build`, so it's unlikley that the resolved serverEntryFilePath doesn't belong to cwd
    if (!cwd)
        return null;
    let serverEntryFilePath;
    try {
        serverEntryFilePath = paths.serverEntryFilePathResolved();
    }
    catch {
        // serverEntryFilePathResolved() calls require.resolve() / require.resolve()
        // - Edge environments don't support require.resolve() / require.resolve()
        // - This code block is executed on edge environments that implement a dummy `process.cwd()` e.g. on Cloudflare Workers `process.cwd() === '/'`
        return null;
    }
    serverEntryFilePath = removeFilePrefix(serverEntryFilePath);
    if ((0, utils_js_1.isWebpackResolve)(serverEntryFilePath, cwd))
        return null;
    serverEntryFilePath = (0, utils_js_1.toPosixPath)(serverEntryFilePath);
    (0, utils_js_1.assertPosixPath)(cwd);
    return !serverEntryFilePath.startsWith(cwd);
}
// Needed for require.resolve()
function removeFilePrefix(filePath) {
    (0, utils_js_1.assert)(process); // We are in a Node.js-like environment
    const filePrefix = process.platform === 'win32' ? 'file:///' : 'file://';
    if (filePath.startsWith(filePrefix))
        filePath = filePath.slice(filePrefix.length);
    return filePath;
}
