"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.assert = assert;
exports.assertUsage = assertUsage;
exports.assertWarning = assertWarning;
exports.assertInfo = assertInfo;
exports.getProjectError = getProjectError;
exports.addOnBeforeLogHook = addOnBeforeLogHook;
exports.getAssertErrMsg = getAssertErrMsg;
exports.overwriteAssertProductionLogger = overwriteAssertProductionLogger;
exports.isBug = isBug;
exports.setAlwaysShowStackTrace = setAlwaysShowStackTrace;
const assertSingleInstance_js_1 = require("./assertSingleInstance.js");
const createErrorWithCleanStackTrace_js_1 = require("./createErrorWithCleanStackTrace.js");
const getGlobalObject_js_1 = require("./getGlobalObject.js");
const isObject_js_1 = require("./isObject.js");
const PROJECT_VERSION_js_1 = require("./PROJECT_VERSION.js");
const picocolors_1 = __importDefault(require("@brillout/picocolors"));
const globalObject = (0, getGlobalObject_js_1.getGlobalObject)('utils/assert.ts', {
    alreadyLogged: new Set(),
    // Production logger. Overwritten by loggerNotProd.ts in non-production environments.
    logger(msg, logType) {
        if (logType === 'info') {
            console.log(msg);
        }
        else {
            console.warn(msg);
        }
    },
    showStackTraceList: new WeakSet(),
});
(0, assertSingleInstance_js_1.assertSingleInstance_onAssertModuleLoad)();
const projectTag = `[vike]`;
const projectTagWithVersion = `[vike@${PROJECT_VERSION_js_1.PROJECT_VERSION}]`;
const bugTag = 'Bug';
const numberOfStackTraceLinesToRemove = 2;
function assert(condition, debugInfo) {
    if (condition)
        return;
    const debugStr = (() => {
        if (!debugInfo) {
            return null;
        }
        const debugInfoSerialized = typeof debugInfo === 'string' ? debugInfo : JSON.stringify(debugInfo);
        return picocolors_1.default.dim(`Debug info for Vike maintainers (you can ignore this): ${debugInfoSerialized}`);
    })();
    const link = picocolors_1.default.underline('https://github.com/vikejs/vike/issues/new?template=bug.yml');
    let errMsg = [
        `You stumbled upon a Vike bug. Go to ${link} and copy-paste this error. A maintainer will fix the bug (usually within 24 hours).`,
        debugStr,
    ]
        .filter(Boolean)
        .join(' ');
    errMsg = addWhitespace(errMsg);
    errMsg = addPrefixAssertType(errMsg, bugTag);
    errMsg = addPrefixProjectName(errMsg, true);
    const internalError = (0, createErrorWithCleanStackTrace_js_1.createErrorWithCleanStackTrace)(errMsg, numberOfStackTraceLinesToRemove);
    globalObject.onBeforeLog?.();
    throw internalError;
}
function assertUsage(condition, errMsg, { showStackTrace, exitOnError } = {}) {
    if (condition)
        return;
    showStackTrace = showStackTrace || globalObject.alwaysShowStackTrace;
    errMsg = addWhitespace(errMsg);
    errMsg = addPrefixAssertType(errMsg, 'Wrong Usage');
    errMsg = addPrefixProjectName(errMsg);
    const usageError = (0, createErrorWithCleanStackTrace_js_1.createErrorWithCleanStackTrace)(errMsg, numberOfStackTraceLinesToRemove);
    if (showStackTrace) {
        globalObject.showStackTraceList.add(usageError);
    }
    globalObject.onBeforeLog?.();
    if (!exitOnError) {
        throw usageError;
    }
    else {
        console.error(showStackTrace ? usageError : errMsg);
        process.exit(1);
    }
}
function getProjectError(errMsg) {
    errMsg = addWhitespace(errMsg);
    errMsg = addPrefixAssertType(errMsg, 'Error');
    errMsg = addPrefixProjectName(errMsg);
    const projectError = (0, createErrorWithCleanStackTrace_js_1.createErrorWithCleanStackTrace)(errMsg, numberOfStackTraceLinesToRemove);
    return projectError;
}
function assertWarning(condition, msg, { onlyOnce, showStackTrace }) {
    if (condition)
        return;
    showStackTrace = showStackTrace || globalObject.alwaysShowStackTrace;
    msg = addWhitespace(msg);
    msg = addPrefixAssertType(msg, 'Warning');
    msg = addPrefixProjectName(msg);
    if (onlyOnce) {
        const { alreadyLogged } = globalObject;
        const key = onlyOnce === true ? msg : onlyOnce;
        if (alreadyLogged.has(key))
            return;
        alreadyLogged.add(key);
    }
    globalObject.onBeforeLog?.();
    if (showStackTrace) {
        const err = (0, createErrorWithCleanStackTrace_js_1.createErrorWithCleanStackTrace)(msg, numberOfStackTraceLinesToRemove);
        globalObject.showStackTraceList.add(err);
        globalObject.logger(err, 'warn');
    }
    else {
        globalObject.logger(msg, 'warn');
    }
}
function assertInfo(condition, msg, { onlyOnce }) {
    if (condition) {
        return;
    }
    msg = addWhitespace(msg);
    msg = addPrefixProjectName(msg);
    if (onlyOnce) {
        const { alreadyLogged } = globalObject;
        const key = msg;
        if (alreadyLogged.has(key)) {
            return;
        }
        else {
            alreadyLogged.add(key);
        }
    }
    globalObject.onBeforeLog?.();
    globalObject.logger(msg, 'info');
}
function addOnBeforeLogHook(onBeforeLog) {
    globalObject.onBeforeLog = onBeforeLog;
}
function addPrefixAssertType(msg, tag) {
    let prefix = `[${tag}]`;
    const color = tag === 'Warning' ? 'yellow' : 'red';
    prefix = picocolors_1.default.bold(picocolors_1.default[color](prefix));
    return `${prefix}${msg}`;
}
function addWhitespace(msg) {
    if (msg.startsWith('[')) {
        return msg;
    }
    else {
        return ` ${msg}`;
    }
}
function addPrefixProjectName(msg, showProjectVersion = false) {
    const prefix = showProjectVersion ? projectTagWithVersion : projectTag;
    return `${prefix}${msg}`;
}
function getAssertErrMsg(thing) {
    let errMsg;
    let errStack;
    if (typeof thing === 'string') {
        errMsg = thing;
    }
    else if ((0, isObject_js_1.isObject)(thing) && typeof thing.message === 'string' && typeof thing.stack === 'string') {
        errMsg = thing.message;
        errStack = thing.stack;
    }
    else {
        return null;
    }
    for (const tag of [projectTagWithVersion, projectTag]) {
        const showVikeVersion = tag === projectTagWithVersion;
        const errStackPrefix = `Error: ${tag}`;
        if (errStack?.startsWith(errStackPrefix)) {
            if (globalObject.showStackTraceList.has(thing) || isBug(thing)) {
                const assertMsg = errStack.slice(errStackPrefix.length);
                return { assertMsg, showVikeVersion };
            }
        }
        else if (errStack?.includes(tag)) {
            throw new Error('Internal Vike error');
        }
        if (errMsg?.startsWith(tag)) {
            const assertMsg = errMsg.slice(tag.length);
            return { assertMsg, showVikeVersion };
        }
    }
    return null;
}
function overwriteAssertProductionLogger(logger) {
    globalObject.logger = logger;
}
function isBug(err) {
    return String(err).includes(`[${bugTag}]`);
}
// Called upon `DEBUG=vike:error`
function setAlwaysShowStackTrace() {
    globalObject.alwaysShowStackTrace = true;
}
