"use strict";
// Files loaded at config time:
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.loadPointerImport = loadPointerImport;
exports.loadValueFile = loadValueFile;
exports.loadConfigFile = loadConfigFile;
const utils_js_1 = require("../../utils.js");
const transpileAndExecuteFile_js_1 = require("./transpileAndExecuteFile.js");
const resolveVikeConfigInternal_js_1 = require("../resolveVikeConfigInternal.js");
const assertPlusFileExport_js_1 = require("../../../../shared/page-configs/assertPlusFileExport.js");
const picocolors_1 = __importDefault(require("@brillout/picocolors"));
const pointerImports_js_1 = require("./pointerImports.js");
const getConfigFileExport_js_1 = require("./getConfigFileExport.js");
const resolvePointerImport_js_1 = require("./resolvePointerImport.js");
const getConfigDefinedAt_js_1 = require("../../../../shared/page-configs/getConfigDefinedAt.js");
(0, utils_js_1.assertIsNotProductionRuntime)();
// Load pointer import
async function loadPointerImport(pointerImport, userRootDir, configName, configDefinitions, esbuildCache) {
    // The value of `extends` was already loaded and already used: we don't need the value of `extends` anymore
    if (configName === 'extends')
        return;
    const configDef = (0, resolveVikeConfigInternal_js_1.getConfigDefinitionOptional)(configDefinitions, configName);
    // Only load pointer import if `env.config===true`
    if (!configDef || !shouldBeLoadableAtBuildTime(configDef))
        return;
    const configDefinedAt = (0, getConfigDefinedAt_js_1.getConfigDefinedAt)('Config', configName, pointerImport.fileExportPath);
    (0, utils_js_1.assertUsage)(pointerImport.fileExportPath.filePathAbsoluteFilesystem, `${configDefinedAt} cannot be defined over an aliased import`);
    const { fileExports } = await (0, transpileAndExecuteFile_js_1.transpileAndExecuteFile)(pointerImport.fileExportPath, userRootDir, false, esbuildCache);
    const fileExportValue = fileExports[pointerImport.fileExportPath.fileExportName];
    pointerImport.fileExportValueLoaded = true;
    (0, utils_js_1.assert)(pointerImport.fileExportValueLoaded);
    pointerImport.fileExportValue = fileExportValue;
}
// Load +{configName}.js
async function loadValueFile(interfaceValueFile, configDefinitions, userRootDir, esbuildCache) {
    const { configName } = interfaceValueFile;
    const configDef = (0, resolveVikeConfigInternal_js_1.getConfigDefinitionOptional)(configDefinitions, configName);
    // Only load value files with `env.config===true`
    if (!configDef || !shouldBeLoadableAtBuildTime(configDef))
        return;
    interfaceValueFile.isNotLoaded = false;
    (0, utils_js_1.assert)(!interfaceValueFile.isNotLoaded);
    interfaceValueFile.fileExportsByConfigName = {};
    const { fileExports } = await (0, transpileAndExecuteFile_js_1.transpileAndExecuteFile)(interfaceValueFile.filePath, userRootDir, false, esbuildCache);
    const { filePathToShowToUser } = interfaceValueFile.filePath;
    (0, assertPlusFileExport_js_1.assertPlusFileExport)(fileExports, filePathToShowToUser, configName);
    Object.entries(fileExports).forEach(([exportName, configValue]) => {
        const configName_ = exportName === 'default' ? configName : exportName;
        interfaceValueFile.fileExportsByConfigName[configName_] = configValue;
    });
}
// Load +config.js, including all its extends pointer imports
async function loadConfigFile(configFilePath, userRootDir, visited, isExtensionConfig, esbuildCache) {
    const { filePathAbsoluteFilesystem } = configFilePath;
    assertNoInfiniteLoop(visited, filePathAbsoluteFilesystem);
    const { fileExports } = await (0, transpileAndExecuteFile_js_1.transpileAndExecuteFile)(configFilePath, userRootDir, isExtensionConfig, esbuildCache);
    const { extendsConfigs, extendsFilePaths } = await loadExtendsConfigs(fileExports, configFilePath, userRootDir, [...visited, filePathAbsoluteFilesystem], esbuildCache);
    const configFile = {
        fileExports,
        filePath: configFilePath,
        extendsFilePaths,
    };
    return { configFile, extendsConfigs };
}
function assertNoInfiniteLoop(visited, filePathAbsoluteFilesystem) {
    const idx = visited.indexOf(filePathAbsoluteFilesystem);
    if (idx === -1)
        return;
    const loop = visited.slice(idx);
    (0, utils_js_1.assert)(loop[0] === filePathAbsoluteFilesystem);
    (0, utils_js_1.assertUsage)(idx === -1, `Infinite extends loop ${[...loop, filePathAbsoluteFilesystem].join('>')}`);
}
async function loadExtendsConfigs(configFileExports, configFilePath, userRootDir, visited, esbuildCache) {
    const { extendsPointerImportData, extendsConfigs } = getExtendsPointerImportData(configFileExports, configFilePath);
    const extendsConfigFiles = [];
    extendsPointerImportData.map((pointerImportData) => {
        const filePath = (0, resolvePointerImport_js_1.resolvePointerImportData)(pointerImportData, configFilePath, userRootDir);
        (0, utils_js_1.assert)(filePath.filePathAbsoluteFilesystem);
        extendsConfigFiles.push(filePath);
    });
    const results = await Promise.all(extendsConfigFiles.map(async (configFilePath) => await loadConfigFile(configFilePath, userRootDir, visited, true, esbuildCache)));
    results.forEach((result) => {
        extendsConfigs.push(result.configFile);
        extendsConfigs.push(...result.extendsConfigs);
    });
    const extendsFilePaths = extendsConfigFiles.map((f) => f.filePathAbsoluteFilesystem);
    return { extendsConfigs, extendsFilePaths };
}
function getExtendsPointerImportData(configFileExports, configFilePath) {
    const { filePathToShowToUser } = configFilePath;
    const configFileExport = (0, getConfigFileExport_js_1.getConfigFileExport)(configFileExports, filePathToShowToUser);
    const extendsConfigs = [];
    const extendsPointerImportData = [];
    if ('extends' in configFileExport) {
        const extendsValue = configFileExport.extends;
        const extendList = [];
        const wrongUsage = `${filePathToShowToUser} sets the config ${picocolors_1.default.cyan('extends')} to an invalid value, see https://vike.dev/extends`;
        if (typeof extendsValue === 'string') {
            extendList.push(extendsValue);
        }
        else if ((0, utils_js_1.isArrayOfStrings)(extendsValue)) {
            extendList.push(...extendsValue);
        }
        else if ((0, utils_js_1.isObject)(extendsValue)) {
            /* If we want to implement this then we need to make filePath optional
            extendsConfigs.push({
              fileExports: extendsValue,
              filePath: null,
            })
            */
            (0, utils_js_1.assertUsage)(false, wrongUsage);
        }
        else {
            (0, utils_js_1.assertUsage)(false, wrongUsage);
        }
        extendsPointerImportData.push(...extendList.map((importString) => {
            const pointerImportData = (0, pointerImports_js_1.parsePointerImportData)(importString);
            (0, utils_js_1.assertUsage)(pointerImportData, wrongUsage);
            return pointerImportData;
        }));
    }
    return { extendsPointerImportData, extendsConfigs };
}
function shouldBeLoadableAtBuildTime(configDef) {
    return !!configDef.env.config && !configDef._valueIsFilePath;
}
