"use strict";
// TO-DO/eventually:
// - New hook onLog(): https://github.com/vikejs/vike/issues/1438
// - Exact same logs between prod and dev, only difference is that some log objects have:
//   - `isDevLog: true`
//   - `willBeLogged: false` in production
//   - `showTimestamp: true`
// - Never clear screen (it's complex with little benefit)
//   - Add shortcut to clear screen
//   - Maybe rotate colors upon no requests within 30s?
// - Only show a one-liner init log (instead of Vite's multi-line log)
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.logViteAny = logViteAny;
exports.logViteError = logViteError;
exports.logConfigInfo = logConfigInfo;
exports.logConfigError = logConfigError;
exports.logConfigErrorRecover = logConfigErrorRecover;
exports.logErrorDebugNote = logErrorDebugNote;
const abort_js_1 = require("../../../shared/route/abort.js");
const globalContext_js_1 = require("../../runtime/globalContext.js");
const loggerRuntime_js_1 = require("../../runtime/loggerRuntime.js");
const utils_js_1 = require("../utils.js");
const getHttpRequestAsyncStore_js_1 = require("./getHttpRequestAsyncStore.js");
const isErrorDebug_js_1 = require("../../shared/isErrorDebug.js");
const errorWithCodeSnippet_js_1 = require("./loggerNotProd/errorWithCodeSnippet.js");
const transpileAndExecuteFile_js_1 = require("./resolveVikeConfigInternal/transpileAndExecuteFile.js");
const log_js_1 = require("./loggerNotProd/log.js");
const picocolors_1 = __importDefault(require("@brillout/picocolors"));
const isNewError_js_1 = require("../../runtime/renderPage/isNewError.js");
const loggerProd_js_1 = require("../../runtime/renderPage/loggerProd.js");
const execHook_js_1 = require("../../../shared/hooks/execHook.js");
(0, utils_js_1.assertIsNotProductionRuntime)();
(0, loggerRuntime_js_1.overwriteRuntimeProductionLogger)(logRuntimeError, logRuntimeInfo);
(0, utils_js_1.overwriteAssertProductionLogger)(assertLogger);
function logRuntimeInfo(msg, httpRequestId, logType) {
    const category = getCategory(httpRequestId);
    (0, log_js_1.logWithVikeTag)(msg, logType, category);
}
function logViteAny(msg, logType, httpRequestId, prependViteTag) {
    if (prependViteTag) {
        const category = getCategory(httpRequestId);
        (0, log_js_1.logWithViteTag)(msg, logType, category);
    }
    else {
        (0, log_js_1.logDirectly)(msg, logType);
    }
}
function logConfigInfo(msg, logType) {
    const category = getConfigCategory();
    (0, log_js_1.logWithVikeTag)(msg, logType, category);
}
function logConfigErrorRecover() {
    const category = getConfigCategory();
    (0, log_js_1.logWithVikeTag)(globalContext_js_1.vikeConfigErrorRecoverMsg, 'error-recover', category);
}
function logRuntimeError(err, 
// httpRequestId is `null` when pre-rendering
httpRequestId) {
    logErr(err, httpRequestId, false);
}
function logViteError(err, 
// httpRequestId is `undefined` if development environment doesn't support async stores
httpRequestId) {
    logErr(err, httpRequestId, true);
}
function logErr(err, httpRequestId = null, errorComesFromVite) {
    (0, utils_js_1.warnIfErrorIsNotObject)(err);
    if ((0, abort_js_1.isAbortError)(err) && !(0, isErrorDebug_js_1.isErrorDebug)()) {
        return;
    }
    const store = (0, getHttpRequestAsyncStore_js_1.getHttpRequestAsyncStore)();
    (0, isNewError_js_1.setAlreadyLogged)(err);
    if ((0, getHttpRequestAsyncStore_js_1.getHttpRequestAsyncStore)()?.shouldErrorBeSwallowed(err)) {
        if (!(0, isErrorDebug_js_1.isErrorDebug)())
            return;
    }
    else {
        store?.markErrorAsLogged(err);
    }
    const category = getCategory(httpRequestId);
    if (!(0, isErrorDebug_js_1.isErrorDebug)()) {
        if ((0, errorWithCodeSnippet_js_1.isErrorWithCodeSnippet)(err)) {
            // We handle transpile errors globally because wrapping viteDevServer.ssrLoadModule() wouldn't be enough: transpile errors can be thrown not only when calling viteDevServer.ssrLoadModule() but also later when loading user code with import() (since Vite lazy-transpiles import() calls)
            const viteConfig = (0, globalContext_js_1.getViteConfig)();
            (0, utils_js_1.assert)(viteConfig);
            const prettyErr = (0, errorWithCodeSnippet_js_1.getPrettyErrorWithCodeSnippet)(err, viteConfig.root);
            (0, utils_js_1.assert)((0, utils_js_1.stripAnsi)(prettyErr).startsWith('Failed to transpile'));
            (0, log_js_1.logWithViteTag)(prettyErr, 'error', category);
            logErrorDebugNote();
            return;
        }
        {
            const logged = handleAssertMsg(err, category);
            if (logged)
                return;
        }
    }
    // Needs to be after assertion messages handling, because user hooks may throw an assertion error
    const hook = (0, execHook_js_1.isUserHookError)(err);
    if (hook) {
        const { hookName, hookFilePath } = hook;
        (0, log_js_1.logWithVikeTag)(picocolors_1.default.red(`Following error was thrown by the ${hookName}() hook defined at ${hookFilePath}`), 'error', category);
    }
    else if (category) {
        logFallbackErrIntro(category, errorComesFromVite);
    }
    (0, log_js_1.logDirectly)(err, 'error');
    // Needs to be called after logging the error.
    (0, loggerProd_js_1.onRuntimeError)(err);
}
function logConfigError(err) {
    (0, utils_js_1.warnIfErrorIsNotObject)(err);
    const category = getConfigCategory();
    {
        const errIntroMsg = (0, transpileAndExecuteFile_js_1.getConfigExecutionErrorIntroMsg)(err);
        if (errIntroMsg) {
            (0, utils_js_1.assert)((0, utils_js_1.stripAnsi)(errIntroMsg).startsWith('Failed to execute'));
            (0, log_js_1.logWithVikeTag)(errIntroMsg, 'error', category);
            (0, log_js_1.logDirectly)(err, 'error');
            return;
        }
    }
    {
        const errMsgFormatted = (0, transpileAndExecuteFile_js_1.getConfigBuildErrorFormatted)(err);
        if (errMsgFormatted) {
            (0, utils_js_1.assert)((0, utils_js_1.stripAnsi)(errMsgFormatted).startsWith('Failed to transpile'));
            if (!(0, isErrorDebug_js_1.isErrorDebug)()) {
                (0, log_js_1.logWithVikeTag)(errMsgFormatted, 'error', category);
            }
            else {
                (0, log_js_1.logDirectly)(err, 'error');
            }
            return;
        }
    }
    {
        const logged = handleAssertMsg(err, category);
        if (logged)
            return;
    }
    if (category)
        logFallbackErrIntro(category, false);
    (0, log_js_1.logDirectly)(err, 'error');
}
function logFallbackErrIntro(category, errorComesFromVite) {
    const msg = errorComesFromVite ? 'Transpilation error' : 'An error was thrown';
    (0, log_js_1.logWithVikeTag)(picocolors_1.default.bold(picocolors_1.default.red(`[Error] ${msg}:`)), 'error', category);
}
function getConfigCategory() {
    const category = getCategory() ?? 'config';
    return category;
}
function handleAssertMsg(err, category) {
    const res = (0, utils_js_1.getAssertErrMsg)(err);
    if (!res)
        return false;
    const { assertMsg, showVikeVersion } = res;
    (0, log_js_1.logWithVikeTag)(assertMsg, 'error', category, showVikeVersion);
    return true;
}
function assertLogger(thing, logType) {
    // vite.ssrFixStacktrace() is needed for `assertWarning(..., { showStackTrace: true })`
    (0, log_js_1.applyViteSourceMapToStackTrace)(thing);
    const category = getCategory();
    const res = (0, utils_js_1.getAssertErrMsg)(thing);
    /* Risk of infinite loop
    assert(res)
    */
    if (!res)
        throw new Error('Internal Vike error, reach out to a maintainer');
    const { assertMsg, showVikeVersion } = res;
    (0, log_js_1.logWithVikeTag)(assertMsg, logType, category, showVikeVersion);
}
/** Note shown to user when vike does something risky:
 *  - When vike dedupes (i.e. swallows) an error with getHttpRequestAsyncStore().shouldErrorBeSwallowed(err)
 *  - When vike modifies the error with getPrettyErrorWithCodeSnippet(err)
 */
function logErrorDebugNote() {
    if ((0, isErrorDebug_js_1.isErrorDebug)())
        return;
    const store = (0, getHttpRequestAsyncStore_js_1.getHttpRequestAsyncStore)();
    if (store) {
        if (store.errorDebugNoteAlreadyShown)
            return;
        store.errorDebugNoteAlreadyShown = true;
    }
    const msg = picocolors_1.default.dim((0, utils_js_1.formatHintLog)("Error isn't helpful? See https://vike.dev/debug#verbose-errors"));
    (0, log_js_1.logDirectly)(msg, 'error');
}
function getCategory(httpRequestId = null) {
    const store = (0, getHttpRequestAsyncStore_js_1.getHttpRequestAsyncStore)();
    if (store?.httpRequestId !== undefined) {
        if (httpRequestId === null) {
            httpRequestId = store.httpRequestId;
        }
        else {
            (0, utils_js_1.assert)(httpRequestId === store.httpRequestId);
        }
    }
    if (httpRequestId === null)
        return null;
    // const category = httpRequestId % 2 === 1 ? (`request-${httpRequestId}` as const) : (`request(${httpRequestId})` as const)
    const category = `request(${httpRequestId})`;
    return category;
}
