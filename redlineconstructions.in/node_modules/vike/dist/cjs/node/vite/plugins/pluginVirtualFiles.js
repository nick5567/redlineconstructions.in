"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.pluginVirtualFiles = pluginVirtualFiles;
const vite_1 = require("vite");
const getVirtualFilePageConfigLazy_js_1 = require("./pluginVirtualFiles/getVirtualFilePageConfigLazy.js");
const getVirtualFileEntry_js_1 = require("./pluginVirtualFiles/getVirtualFileEntry.js");
const utils_js_1 = require("../utils.js");
const virtualFiles_js_1 = require("../../shared/virtualFiles.js");
const virtualFilePageConfigLazy_js_1 = require("../../shared/virtualFiles/virtualFilePageConfigLazy.js");
const virtualFileEntry_js_1 = require("../../shared/virtualFiles/virtualFileEntry.js");
const resolveVikeConfigInternal_js_1 = require("../shared/resolveVikeConfigInternal.js");
const picocolors_1 = __importDefault(require("@brillout/picocolors"));
const loggerNotProd_js_1 = require("../shared/loggerNotProd.js");
const getFilePath_js_1 = require("../shared/getFilePath.js");
const globalContext_js_1 = require("../../runtime/globalContext.js");
const crawlPlusFiles_js_1 = require("../shared/resolveVikeConfigInternal/crawlPlusFiles.js");
const transpileAndExecuteFile_js_1 = require("../shared/resolveVikeConfigInternal/transpileAndExecuteFile.js");
const getVikeConfigError_js_1 = require("../../shared/getVikeConfigError.js");
function pluginVirtualFiles() {
    let config;
    return {
        name: 'vike:pluginVirtualFiles',
        async configResolved(config_) {
            config = config_;
            // TO-DO/next-major-release: remove
            if (!(0, resolveVikeConfigInternal_js_1.isV1Design)())
                config.experimental.importGlobRestoreExtension = true;
        },
        resolveId(id) {
            if ((0, virtualFiles_js_1.isVirtualFileId)(id)) {
                return (0, virtualFiles_js_1.resolveVirtualFileId)(id);
            }
        },
        async handleHotUpdate(ctx) {
            try {
                return await handleHotUpdate(ctx, config);
            }
            catch (err) {
                // Vite swallows errors thrown by handleHotUpdate()
                console.error(err);
                throw err;
            }
        },
        async load(id, options) {
            if (!(0, virtualFiles_js_1.isVirtualFileId)(id))
                return undefined;
            id = (0, virtualFiles_js_1.getVirtualFileId)(id);
            const isDev = config._isDev;
            (0, utils_js_1.assert)(typeof isDev === 'boolean');
            if ((0, virtualFilePageConfigLazy_js_1.isVirtualFileIdPageConfigLazy)(id)) {
                const code = await (0, getVirtualFilePageConfigLazy_js_1.getVirtualFilePageConfigLazy)(id, isDev, config);
                return code;
            }
            if ((0, virtualFileEntry_js_1.isVirtualFileIdEntry)(id)) {
                const code = await (0, getVirtualFileEntry_js_1.getVirtualFileEntry)(id, options, config, isDev);
                return code;
            }
        },
        configureServer(server) {
            handleFileAddRemove(server, config);
        },
    };
}
function handleFileAddRemove(server, config) {
    server.watcher.prependListener('add', (f) => listener(f, false));
    server.watcher.prependListener('unlink', (f) => listener(f, true));
    return;
    async function listener(file, isRemove) {
        file = (0, vite_1.normalizePath)(file);
        if ((0, transpileAndExecuteFile_js_1.isTemporaryBuildFile)(file))
            return;
        const { moduleGraph } = server;
        const isVikeConfigDep = await isVikeConfigDependency(file, moduleGraph);
        const reload = () => reloadConfig(file, config, isRemove ? 'removed' : 'created', server);
        // Config code
        if (isVikeConfigDep && !isVikeConfigDep.isProcessedByVite) {
            reload();
            return;
        }
        // New or deleted + file
        if ((0, crawlPlusFiles_js_1.isPlusFile)(file)) {
            reload();
            return;
        }
        // Runtime code => let Vite handle it
        if (isVikeConfigDep && isVikeConfigDep.isProcessedByVite) {
            (0, utils_js_1.assert)(existsInViteModuleGraph(file, moduleGraph));
            return;
        }
        // Trick: when importing a file that doesn't exist => we don't know whether `file` is that missing file => we take a leap of faith when the conditions below are met.
        // - Not sure how reliable that trick is.
        // - Reloading Vike's config is cheap and file creation/removal is rare => the trick is worth it.
        // - Reproduction:
        //   ```bash
        //   rm someDep.js && sleep 2 && git checkout someDep.js
        //   ```
        if ((0, utils_js_1.isScriptFile)(file) && (0, getVikeConfigError_js_1.getVikeConfigError)() && !existsInViteModuleGraph(file, moduleGraph)) {
            reload();
            return;
        }
    }
}
function invalidateVikeVirtualFiles(server) {
    const vikeVirtualFiles = getVikeVirtualFiles(server);
    vikeVirtualFiles.forEach((mod) => {
        server.moduleGraph.invalidateModule(mod);
    });
}
// Vite calls its hook handleHotUpdate() whenever *any file* is modified â€” including files that aren't in Vite's module graph such as `pages/+config.js`
async function handleHotUpdate(ctx, config) {
    const { file, server } = ctx;
    const isVikeConfigDep = await isVikeConfigDependency(ctx.file, ctx.server.moduleGraph);
    if (isVikeConfigDep) {
        if (!isVikeConfigDep.isProcessedByVite) {
            /* Tailwind breaks this assertion, see https://github.com/vikejs/vike/discussions/1330#discussioncomment-7787238
            const isViteModule = ctx.modules.length > 0
            assert(!isViteModule)
            */
            reloadConfig(file, config, 'modified', server);
            // Files such as `pages/+config.js` can potentially modify Vike's virtual files.
            // Triggers a full page reload
            const vikeVirtualFiles = getVikeVirtualFiles(server);
            return vikeVirtualFiles;
        }
        else {
            // Ensure we invalidate `file` *before* server.ssrLoadModule() in updateUserFiles()
            // Vite already invalidates it, but *after* handleHotUpdate() and thus after server.ssrLoadModule()
            ctx.modules.forEach((mod) => server.moduleGraph.invalidateModule(mod));
            (0, globalContext_js_1.updateUserFiles)();
        }
    }
}
async function isVikeConfigDependency(filePathAbsoluteFilesystem, moduleGraph) {
    // Non-runtime Vike config files such as `pages/+config.js` which aren't processed by Vite.
    // - They're missing in Vite's module graph.
    // - Potentially modifies Vike's virtual files.
    // - Same for all `pages/+config.js` dependencies.
    (0, utils_js_1.assertPosixPath)(filePathAbsoluteFilesystem);
    const vikeConfigObject = await (0, resolveVikeConfigInternal_js_1.getVikeConfigInternalOptional)();
    if (vikeConfigObject) {
        const { _vikeConfigDependencies: vikeConfigDependencies } = vikeConfigObject;
        vikeConfigDependencies.forEach((f) => (0, utils_js_1.assertPosixPath)(f));
        if (vikeConfigDependencies.has(filePathAbsoluteFilesystem))
            return { isProcessedByVite: false };
    }
    // Runtime Vike config files such as +data.js which are processed by Vite.
    // - They're included in Vite's module graph.
    // - They never modify Vike's virtual files.
    // - Same for all `+data.js` dependencies.
    const importers = getImporters(filePathAbsoluteFilesystem, moduleGraph);
    const isPlusValueFileDependency = Array.from(importers).some((importer) => importer.file && (0, crawlPlusFiles_js_1.isPlusFile)(importer.file));
    if (isPlusValueFileDependency)
        return { isProcessedByVite: true };
    return null;
}
function reloadConfig(filePath, config, op, server) {
    // Ensure server.ssrLoadModule() loads fresh Vike virtual files (`reloadConfig()` > `updateUserFiles()` > `server.ssrLoadModule()`)
    invalidateVikeVirtualFiles(server);
    {
        const filePathToShowToUserResolved = (0, getFilePath_js_1.getModuleFilePathAbsolute)(filePath, config);
        const msg = `${op} ${picocolors_1.default.dim(filePathToShowToUserResolved)}`;
        (0, loggerNotProd_js_1.logConfigInfo)(msg, 'info');
    }
    (0, resolveVikeConfigInternal_js_1.reloadVikeConfig)();
    (0, globalContext_js_1.updateUserFiles)();
}
function getVikeVirtualFiles(server) {
    const vikeVirtualFiles = Array.from(server.moduleGraph.urlToModuleMap.keys())
        .filter((url) => (0, virtualFilePageConfigLazy_js_1.isVirtualFileIdPageConfigLazy)(url) || (0, virtualFileEntry_js_1.isVirtualFileIdEntry)(url))
        .map((url) => {
        const mod = server.moduleGraph.urlToModuleMap.get(url);
        (0, utils_js_1.assert)(mod);
        return mod;
    });
    return vikeVirtualFiles;
}
// Get all transitive importers (including the module itself)
function getImporters(file, moduleGraph) {
    const importers = new Set();
    const mods = moduleGraph.getModulesByFile(file);
    if (!mods)
        return importers;
    for (const mod of mods) {
        getModuleImporters(mod).forEach((importer) => {
            if (importer)
                importers.add(importer);
        });
    }
    return importers;
}
function getModuleImporters(mod, seen = new Set()) {
    if (seen.has(mod))
        return new Set();
    seen.add(mod);
    const importers = new Set();
    if (mod.id)
        importers.add(mod);
    // Traverse through the importers (modules that import this module)
    for (const importer of mod.importers) {
        if (importer.id)
            importers.add(importer);
        getModuleImporters(importer, seen).forEach((importerTransitive) => {
            if (importerTransitive)
                importers.add(importerTransitive);
        });
    }
    return importers;
}
function existsInViteModuleGraph(file, moduleGraph) {
    return !!moduleGraph.getModulesByFile(file);
}
