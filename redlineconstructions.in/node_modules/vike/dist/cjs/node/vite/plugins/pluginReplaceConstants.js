"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.pluginReplaceConstants = pluginReplaceConstants;
const magic_string_1 = __importDefault(require("magic-string"));
const utils_js_1 = require("../utils.js");
const normalizeId_js_1 = require("../shared/normalizeId.js");
const isViteServerBuild_js_1 = require("../shared/isViteServerBuild.js");
const applyRegExWithMagicString_js_1 = require("../shared/applyRegExWithMagicString.js");
function pluginReplaceConstants() {
    let config;
    return {
        name: 'vike:pluginReplaceConstants',
        enforce: 'post',
        apply: 'build',
        configResolved(config_) {
            config = config_;
        },
        transform(code, id, options) {
            id = (0, normalizeId_js_1.normalizeId)(id);
            (0, utils_js_1.assertPosixPath)(id);
            if (id.includes('/node_modules/'))
                return;
            (0, utils_js_1.assertPosixPath)(config.root);
            if (!id.startsWith(config.root))
                return;
            if (!code.includes('import.meta.env.'))
                return;
            const isBuild = config.command === 'build';
            (0, utils_js_1.assert)(isBuild);
            // Used by vike.dev
            // https://github.com/vikejs/vike/blob/08a1ff55c80ddca64ca6d4417fefd45fefeb4ffb/docs/vite.config.ts#L12
            // @ts-expect-error
            if (config._skipVikeReplaceConstants?.(id))
                return;
            const magicString = new magic_string_1.default(code);
            const constantsMap = [];
            constantsMap.push({
                constants: ['pageContext.isClientSide', 'globalContext.isClientSide', 'pageContext.globalContext.isClientSide'],
                replacement: !(0, isViteServerBuild_js_1.isViteServerBuild_safe)(config, options),
            });
            constantsMap.forEach(({ constants, replacement }) => {
                if (!constants.some((c) => code.includes(c)))
                    return;
                const regExp = getConstantRegExp(constants);
                (0, applyRegExWithMagicString_js_1.applyRegExpWithMagicString)(magicString, regExp, replacement);
            });
            if (!magicString.hasChanged())
                return null;
            return {
                code: magicString.toString(),
                map: magicString.generateMap({ hires: true, source: id }),
            };
        },
    };
}
// Copied & adapted from:
// https://github.com/rollup/plugins/blob/e1a5ef99f1578eb38a8c87563cb9651db228f3bd/packages/replace/src/index.js#L57-L67
function getConstantRegExp(constants) {
    const keys = Object.values(constants).sort(longest).map(escape);
    // const delimiters = ['\\b', '\\b(?!\\.)']
    const delimiters = ['(?<!\\.)\\b', '\\b(?!\\.)']; // Improved version, to avoid replacing `globalContext.pageContext.isClientSide` with `globalContext.false`
    const preventAssignment = false; // Let's try without it first, let's see if a user complains
    const lookbehind = preventAssignment ? '(?<!\\b(?:const|let|var)\\s*)' : '';
    const lookahead = preventAssignment ? '(?!\\s*=[^=])' : '';
    const pattern = new RegExp(`${lookbehind}${delimiters[0]}(${keys.join('|')})${delimiters[1]}${lookahead}`, 'g');
    return pattern;
}
function escape(str) {
    return str.replace(/[-[\]/{}()*+?.\\^$|]/g, '\\$&');
}
function longest(a, b) {
    return b.length - a.length;
}
