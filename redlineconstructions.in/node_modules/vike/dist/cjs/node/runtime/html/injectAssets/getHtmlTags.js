"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getHtmlTags = getHtmlTags;
const isFontFallback_js_1 = require("../../renderPage/isFontFallback.js");
const utils_js_1 = require("../../utils.js");
const serializeContext_js_1 = require("../serializeContext.js");
const sanitizeJson_js_1 = require("./sanitizeJson.js");
const inferHtmlTags_js_1 = require("./inferHtmlTags.js");
const mergeScriptTags_js_1 = require("./mergeScriptTags.js");
const helpers_js_1 = require("../../../../shared/page-configs/helpers.js");
const getConfigValueRuntime_js_1 = require("../../../../shared/page-configs/getConfigValueRuntime.js");
const picocolors_1 = __importDefault(require("@brillout/picocolors"));
const getConfigDefinedAt_js_1 = require("../../../../shared/page-configs/getConfigDefinedAt.js");
const htmlElementIds_js_1 = require("../../../../shared/htmlElementIds.js");
const stamp = '__injectFilterEntry';
async function getHtmlTags(pageContext, streamFromReactStreamingPackage, injectFilter, pageAssets, viteDevScript, isStream) {
    (0, utils_js_1.assert)([true, false].includes(pageContext._isHtmlOnly));
    const isHtmlOnly = pageContext._isHtmlOnly;
    const { _isProduction: isProduction } = pageContext._globalContext;
    const injectScriptsAt = getInjectScriptsAt(pageContext.pageId, pageContext._globalContext._pageConfigs);
    const injectFilterEntries = [];
    pageAssets
        .filter((asset) => {
        if (asset.isEntry && asset.assetType === 'script') {
            // We could allow the user to change the position of <script> but we currently don't:
            //  - Because of mergeScriptEntries()
            //  - We would need to add HTML_STREAM to to PreloadFilterInject
            // To support this, we should add the JavaScript entry to injectFilterEntries (with an `src` value of `null`)
            return false;
        }
        return true;
    })
        .forEach((asset) => {
        const inject = (() => {
            if (!isProduction) {
                // In development, we should always load assets as soon as possible, in order to eagerly process assets (e.g. applying the transform() hooks of Vite plugins) which are lazily discovered.
                return 'HTML_BEGIN';
            }
            if (asset.assetType === 'style') {
                return 'HTML_BEGIN';
            }
            if (asset.assetType === 'font') {
                return !(0, isFontFallback_js_1.isFontFallback)(asset, injectFilterEntries) ? 'HTML_BEGIN' : false;
            }
            if (asset.assetType === 'script') {
                if (isHtmlOnly)
                    return false;
                return 'HTML_END';
            }
            return false;
        })();
        const entry = {
            ...asset,
            inject,
            // @ts-ignore
            [stamp]: true,
        };
        injectFilterEntries.push(entry);
    });
    assertInjectFilterEntries(injectFilterEntries);
    // ==============
    // injectFilter()
    // ==============
    if (injectFilter && isProduction) {
        Object.seal(injectFilterEntries); // `Object.seal()` instead of `Object.freeze()` to allow the user to `assets.sort()`
        Object.values(injectFilterEntries).forEach((entry) => (0, utils_js_1.freezePartial)(entry, { inject: (val) => val === false || val === 'HTML_BEGIN' || val === 'HTML_END' }));
        // Call the user's injectFilter() hook https://vike.dev/injectFilter
        const res = injectFilter(injectFilterEntries);
        (0, utils_js_1.assertUsage)(res === undefined, `injectFilter() should return ${picocolors_1.default.cyan('undefined')}, see https://vike.dev/injectFilter`);
        assertInjectFilterUsage(injectFilterEntries);
    }
    const htmlTags = [];
    // ==============
    // Non-JavaScript
    // ==============
    injectFilterEntries
        .filter((asset) => asset.assetType !== 'script' && asset.inject)
        .forEach((asset) => {
        if (!asset.inject)
            return;
        const htmlTag = asset.isEntry ? (0, inferHtmlTags_js_1.inferAssetTag)(asset) : (0, inferHtmlTags_js_1.inferPreloadTag)(asset);
        htmlTags.push({ htmlTag, position: asset.inject });
    });
    // ==========
    // JavaScript
    // ==========
    // - By default, we place the entry <script> towards the end of the HTML for better performance.
    //   - Performance-wise, it's more interesting to start showing the page (parse HTML and load CSS) before starting loading scripts.
    //   - But with HTML streaming, in order to support [Progressive Rendering](https://vike.dev/streaming#progressive-rendering), the entry <script> should be injected earlier instead.
    // - The entry <script> shouldn't be `<script defer>` upon HTML streaming, otherwise progressive hydration while SSR streaming won't work.
    // - `<script id="vike_pageContext" type="application/json">` (the `pageContext` JSON) should be fully sent before Vike's client runtime starts executing.
    //   - Otherwise, race condition "SyntaxError: Unterminated string in JSON": https://github.com/vikejs/vike/issues/567
    //   - `<script id="vike_pageContext" type="application/json">` must appear before the entry <script> (which loads Vike's client runtime).
    //   - `<script id="vike_pageContext" type="application/json">` can't be async nor defer.
    const positionJavaScriptDefault = 'HTML_END';
    const positionJavaScriptEntry = (() => {
        if (injectScriptsAt !== null) {
            if (pageContext._pageContextPromise) {
                (0, utils_js_1.assertWarning)(injectScriptsAt === 'HTML_END' || !isStream, `You're setting injectScriptsAt to ${picocolors_1.default.code(JSON.stringify(injectScriptsAt))} while using HTML streaming with a pageContext promise (https://vike.dev/streaming#initial-data-after-stream-end) which is contradictory: the pageContext promise is skipped.`, { onlyOnce: true });
            }
            if (injectScriptsAt === 'HTML_STREAM' && !isStream) {
                return positionJavaScriptDefault;
            }
            return injectScriptsAt;
        }
        if (pageContext._pageContextPromise) {
            // - If there is a pageContext._pageContextPromise then <script id="vike_pageContext" type="application/json"> needs to await for it.
            // - pageContext._pageContextPromise is typically resolved only after the page's components are rendered and the stream ended.
            // - https://vike.dev/streaming#initial-data-after-stream-end
            return positionJavaScriptDefault;
        }
        if (streamFromReactStreamingPackage && !streamFromReactStreamingPackage.hasStreamEnded()) {
            // If there is a stream then, in order to support progressive hydration, inject the JavaScript during the stream after React(/Vue/Solid/...) resolved the first suspense boundary.
            return 'HTML_STREAM';
        }
        return positionJavaScriptDefault;
    })();
    if (pageContext._pageContextPromise && streamFromReactStreamingPackage) {
        // - Should we show this warning for Solid as well? Solid seems to also support progressive rendering.
        //   - https://github.com/vikejs/vike-solid/issues/95
        // - Vue doesn't seem to support progressive rendering yet.
        //   - https://github.com/vikejs/vike-vue/issues/85
        (0, utils_js_1.assertWarning)(false, "We recommend against using HTML streaming and a pageContext promise (https://vike.dev/streaming#initial-data-after-stream-end) at the same time, because progressive hydration (https://vike.dev/streaming#progressive-rendering) won't work.", { onlyOnce: true });
    }
    if (!isHtmlOnly) {
        // <script id="vike_pageContext" type="application/json">
        htmlTags.push({
            htmlTag: () => 
            // Needs to be called after resolvePageContextPromise()
            getPageContextJsonScriptTag(pageContext),
            position: positionJavaScriptEntry,
        });
        // <script id="vike_globalContext" type="application/json">
        htmlTags.push({
            htmlTag: () => 
            // Needs to be called after resolvePageContextPromise()
            getGlobalContextJsonScriptTag(pageContext),
            position: positionJavaScriptEntry,
        });
    }
    // The JavaScript entry <script> tag
    const scriptEntry = mergeScriptEntries(pageAssets, viteDevScript);
    if (scriptEntry) {
        htmlTags.push({
            htmlTag: scriptEntry,
            position: positionJavaScriptEntry,
        });
    }
    // Preload tags
    injectFilterEntries
        .filter((asset) => asset.assetType === 'script')
        .forEach((asset) => {
        (0, utils_js_1.assert)(!asset.isEntry); // Users cannot re-order JavaScript entries, see creation of injectFilterEntries
        const htmlTag = (0, inferHtmlTags_js_1.inferPreloadTag)(asset);
        if (!asset.inject)
            return;
        // Ideally, instead of this conditional ternary operator, we should add HTML_STREAM to PreloadFilterInject
        const position = asset.inject === 'HTML_END' ? positionJavaScriptEntry : asset.inject;
        htmlTags.push({ htmlTag, position });
    });
    return htmlTags;
}
function mergeScriptEntries(pageAssets, viteDevScript) {
    const scriptEntries = pageAssets.filter((pageAsset) => pageAsset.isEntry && pageAsset.assetType === 'script');
    let scriptEntry = `${viteDevScript}${scriptEntries.map((asset) => (0, inferHtmlTags_js_1.inferAssetTag)(asset)).join('')}`;
    // We merge scripts to avoid the infamous HMR preamble error.
    // - Infamous HMR preamble error:
    //   ```browser-console
    //   usePageContext.tsx:10 Uncaught (in promise) Error: @vitejs/plugin-react can't detect preamble. Something is wrong.
    //       at usePageContext.tsx:10:10
    //   ```
    // - Note the following race condition. Maybe making the second script non-async ensures execution order?
    //   ```html
    //   <script type="module">console.log("I can be printed *after* the other log")</script>
    //   <script src="entry.js" type="module" async></script>
    //   ```
    //   ```js
    //   // entry.js
    //   console.log("I can be printed *before* the other log")
    //   ```
    // - Maybe an alternative would be to make Vike's client runtime entry <script> tag non-async. Would that work? Would it be a performance issue?
    //   - The entry <script> shouldn't be `<script defer>` upon HTML streaming, otherwise progressive hydration while SSR streaming won't work.
    scriptEntry = (0, mergeScriptTags_js_1.mergeScriptTags)(scriptEntry);
    return scriptEntry;
}
function getPageContextJsonScriptTag(pageContext) {
    const pageContextClientSerialized = (0, sanitizeJson_js_1.sanitizeJson)((0, serializeContext_js_1.getPageContextClientSerialized)(pageContext));
    const htmlTag = `<script id="${htmlElementIds_js_1.htmlElementId_pageContext}" type="application/json">${pageContextClientSerialized}</script>`;
    // Used by contra.com https://github.com/gajus
    // @ts-expect-error
    pageContext._pageContextHtmlTag = htmlTag;
    return htmlTag;
}
function getGlobalContextJsonScriptTag(pageContext) {
    const globalContextClientSerialized = (0, sanitizeJson_js_1.sanitizeJson)((0, serializeContext_js_1.getGlobalContextClientSerialized)(pageContext));
    const htmlTag = `<script id="${htmlElementIds_js_1.htmlElementId_globalContext}" type="application/json">${globalContextClientSerialized}</script>`;
    return htmlTag;
}
function assertInjectFilterEntries(injectFilterEntries) {
    try {
        checkForWrongUsage(injectFilterEntries);
    }
    catch (err) {
        if (err?.message.includes('[Wrong Usage]')) {
            (0, utils_js_1.assert)(false);
        }
        throw err;
    }
}
function assertInjectFilterUsage(injectFilterEntries) {
    checkForWrongUsage(injectFilterEntries);
    checkForWarnings(injectFilterEntries);
}
function checkForWrongUsage(injectFilterEntries) {
    injectFilterEntries.forEach((entry, i) => {
        (0, utils_js_1.assertUsage)((0, utils_js_1.isObject)(entry), `[injectFilter()] Entry ${i} isn't an object`);
        (0, utils_js_1.assertUsage)(typeof entry.src === 'string', `[injectFilter()] Entry ${i} is missing property ${picocolors_1.default.cyan('src')}`);
        (0, utils_js_1.assertUsage)(entry[stamp] === true, `[injectFilter()] Entry ${i} (${entry.src}) isn't the original object, see https://vike.dev/injectFilter`);
        (0, utils_js_1.assert)([false, 'HTML_BEGIN', 'HTML_END'].includes(entry.inject));
        (0, utils_js_1.assert)(entry.assetType === null || typeof entry.assetType === 'string');
        (0, utils_js_1.assert)(entry.mediaType === null || typeof entry.mediaType === 'string');
        (0, utils_js_1.assert)(typeof entry.isEntry === 'boolean');
        (0, utils_js_1.assert)(Object.keys(entry).length === 6);
    });
}
function checkForWarnings(injectFilterEntries) {
    injectFilterEntries.forEach((a) => {
        /*
        if (a.assetType === 'script' && a.isEntry) {
          assertUsage(a.inject, `[injectFilter()] ${a.src} needs to be injected`)
        }
        */
        if (a.assetType === 'style' && a.isEntry) {
            // In development, Vite automatically inject styles, but we still inject `<link rel="stylesheet" type="text/css" href="${src}">` tags in order to avoid FOUC (flash of unstyled content).
            //  - https://github.com/vitejs/vite/issues/2282
            //  - https://github.com/vikejs/vike/issues/261
            (0, utils_js_1.assertWarning)(a.inject, `[injectFilter()] We recommend against not injecting ${a.src}`, {
                onlyOnce: true,
            });
        }
        if (a.assetType === 'script') {
            (0, utils_js_1.assertWarning)(a.inject, `[injectFilter()] We recommend against not preloading JavaScript (${a.src})`, {
                onlyOnce: true,
            });
        }
    });
}
function getInjectScriptsAt(pageId, pageConfigs) {
    if (pageConfigs.length === 0)
        return null; // only support V1 design
    const pageConfig = (0, helpers_js_1.getPageConfig)(pageId, pageConfigs);
    const configValue = (0, getConfigValueRuntime_js_1.getConfigValueRuntime)(pageConfig, 'injectScriptsAt');
    if (!configValue)
        return null;
    const injectScriptsAt = configValue.value;
    (0, utils_js_1.assert)(configValue.definedAtData);
    const configDefinedAt = (0, getConfigDefinedAt_js_1.getConfigDefinedAt)('Config', 'injectScriptsAt', configValue.definedAtData);
    (0, utils_js_1.assertUsage)(injectScriptsAt === null ||
        injectScriptsAt === 'HTML_BEGIN' ||
        injectScriptsAt === 'HTML_END' ||
        injectScriptsAt === 'HTML_STREAM', `${configDefinedAt} has an invalid value`);
    return injectScriptsAt;
}
