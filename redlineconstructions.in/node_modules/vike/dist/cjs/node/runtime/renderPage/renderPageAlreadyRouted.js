"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.renderPageAlreadyRouted = renderPageAlreadyRouted;
exports.prerenderPage = prerenderPage;
const error_page_js_1 = require("../../../shared/error-page.js");
const renderHtml_js_1 = require("../html/renderHtml.js");
const utils_js_1 = require("../utils.js");
const serializeContext_js_1 = require("../html/serializeContext.js");
const createHttpResponse_js_1 = require("./createHttpResponse.js");
const loadPageConfigsLazyServerSide_js_1 = require("./loadPageConfigsLazyServerSide.js");
const execHookOnRenderHtml_js_1 = require("./execHookOnRenderHtml.js");
const execHookDataAndOnBeforeRender_js_1 = require("./execHookDataAndOnBeforeRender.js");
const loggerRuntime_js_1 = require("../loggerRuntime.js");
const isNewError_js_1 = require("./isNewError.js");
const preparePageContextForPublicUsageServer_js_1 = require("./preparePageContextForPublicUsageServer.js");
const execHookGuard_js_1 = require("../../../shared/route/execHookGuard.js");
const picocolors_1 = __importDefault(require("@brillout/picocolors"));
const isServerSideError_js_1 = require("../../../shared/misc/isServerSideError.js");
// TODO/now: rename?
async function renderPageAlreadyRouted(pageContext) {
    // pageContext.pageId can either be the:
    //  - ID of the page matching the routing, or the
    //  - ID of the error page `_error.page.js`.
    (0, utils_js_1.assert)((0, utils_js_1.hasProp)(pageContext, 'pageId', 'string'));
    const isError = pageContext.is404 || !!pageContext.errorWhileRendering;
    (0, utils_js_1.assert)(isError ===
        (pageContext.pageId ===
            (0, error_page_js_1.getErrorPageId)(pageContext._globalContext._pageFilesAll, pageContext._globalContext._pageConfigs)));
    (0, utils_js_1.augmentType)(pageContext, await (0, loadPageConfigsLazyServerSide_js_1.loadPageConfigsLazyServerSideAndExecHook)(pageContext));
    if (!isError) {
        await (0, execHookGuard_js_1.execHookGuard)(pageContext, (pageContext) => (0, preparePageContextForPublicUsageServer_js_1.preparePageContextForPublicUsageServer)(pageContext));
    }
    if (!isError) {
        await (0, execHookDataAndOnBeforeRender_js_1.execHookDataAndOnBeforeRender)(pageContext);
    }
    else {
        try {
            await (0, execHookDataAndOnBeforeRender_js_1.execHookDataAndOnBeforeRender)(pageContext);
        }
        catch (err) {
            if ((0, isNewError_js_1.isNewError)(err, pageContext.errorWhileRendering)) {
                (0, loggerRuntime_js_1.logRuntimeError)(err, pageContext._httpRequestId);
            }
        }
    }
    if (pageContext.isClientSideNavigation) {
        if (isError) {
            (0, utils_js_1.objectAssign)(pageContext, { [isServerSideError_js_1.isServerSideError]: true });
        }
        const pageContextSerialized = (0, serializeContext_js_1.getPageContextClientSerialized)(pageContext);
        const httpResponse = await (0, createHttpResponse_js_1.createHttpResponsePageContextJson)(pageContextSerialized);
        (0, utils_js_1.objectAssign)(pageContext, { httpResponse });
        return pageContext;
    }
    const renderHookResult = await (0, execHookOnRenderHtml_js_1.execHookOnRenderHtml)(pageContext);
    const { htmlRender, renderHook } = renderHookResult;
    const httpResponse = await (0, createHttpResponse_js_1.createHttpResponsePage)(htmlRender, renderHook, pageContext);
    (0, utils_js_1.objectAssign)(pageContext, { httpResponse });
    return pageContext;
}
async function prerenderPage(pageContext) {
    (0, utils_js_1.objectAssign)(pageContext, {
        isClientSideNavigation: false,
        _urlHandler: null,
    });
    /* Should we execute the guard() hook upon pre-rendering? Is there a use case for this?
     *  - It isn't trivial to implement, as it requires to duplicate / factor out the isAbortError() handling
    await execHookGuard(pageContext, (pageContext) => preparePageContextForPublicUsageServer(pageContext))
    */
    await (0, execHookDataAndOnBeforeRender_js_1.execHookDataAndOnBeforeRender)(pageContext);
    const { htmlRender, renderHook } = await (0, execHookOnRenderHtml_js_1.execHookOnRenderHtml)(pageContext);
    (0, utils_js_1.assertUsage)(htmlRender !== null, `Cannot pre-render ${picocolors_1.default.cyan(pageContext.urlOriginal)} because the ${renderHook.hookName}() hook defined by ${renderHook.hookFilePath} didn't return an HTML string.`);
    (0, utils_js_1.assert)(pageContext.isClientSideNavigation === false);
    const documentHtml = await (0, renderHtml_js_1.getHtmlString)(htmlRender);
    (0, utils_js_1.assert)(typeof documentHtml === 'string');
    if (!pageContext._usesClientRouter) {
        return { documentHtml, pageContextSerialized: null, pageContext };
    }
    else {
        const pageContextSerialized = (0, serializeContext_js_1.getPageContextClientSerialized)(pageContext);
        return { documentHtml, pageContextSerialized, pageContext };
    }
}
