"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createHttpResponsePage = createHttpResponsePage;
exports.createHttpResponsePageContextJson = createHttpResponsePageContextJson;
exports.createHttpResponseError = createHttpResponseError;
exports.createHttpResponseErrorWithoutGlobalContext = createHttpResponseErrorWithoutGlobalContext;
exports.createHttpResponseRedirect = createHttpResponseRedirect;
exports.createHttpResponse404 = createHttpResponse404;
exports.createHttpResponseBaseIsMissing = createHttpResponseBaseIsMissing;
const utils_js_1 = require("../utils.js");
const error_page_js_1 = require("../../../shared/error-page.js");
const getHttpResponseBody_js_1 = require("./getHttpResponseBody.js");
const getEarlyHints_js_1 = require("./getEarlyHints.js");
const assertNoInfiniteHttpRedirect_js_1 = require("./createHttpResponse/assertNoInfiniteHttpRedirect.js");
const getCacheControl_js_1 = require("./getCacheControl.js");
async function createHttpResponsePage(htmlRender, renderHook, pageContext) {
    let statusCode = pageContext.abortStatusCode;
    if (!statusCode) {
        const isError = !pageContext.pageId || (0, error_page_js_1.isErrorPage)(pageContext.pageId, pageContext._globalContext._pageConfigs);
        if (pageContext.errorWhileRendering) {
            (0, utils_js_1.assert)(isError);
        }
        if (!isError) {
            (0, utils_js_1.assert)(pageContext.is404 === null);
            statusCode = 200;
        }
        else {
            (0, utils_js_1.assert)(pageContext.is404 === true || pageContext.is404 === false);
            statusCode = pageContext.is404 ? 404 : 500;
        }
    }
    const earlyHints = (0, getEarlyHints_js_1.getEarlyHints)(await pageContext.__getPageAssets());
    const headers = [];
    const headersResponse = pageContext.headersResponse || new Headers();
    headersResponse.forEach((value, key) => {
        headers.push([key, value]);
    });
    // An 5xx error page shouldn't be cached (it should be temporary)
    if (statusCode >= 500)
        headersResponse.set('Cache-Control', getCacheControl_js_1.cacheControlDisable);
    return createHttpResponse(statusCode, 'text/html;charset=utf-8', headers, htmlRender, earlyHints, renderHook);
}
function createHttpResponse404(errMsg404) {
    const httpResponse = createHttpResponse(404, 'text/html;charset=utf-8', [], `<p>${errMsg404}.</p><script>console.log('This HTML was generated by Vike.')</script>`);
    return httpResponse;
}
function createHttpResponseBaseIsMissing(urlOriginal, baseServer) {
    const httpResponse = createHttpResponse(
    // We use the error code `500` to signal a failing state because this HTTP response should never be used, see https://vike.dev/base-url#setup
    // In other words: this HTTP response is expected to be generated but isn't expected to be actually used.
    500, 'text/html;charset=utf-8', [], `
<h1>Error: Base URL is missing</h1>
<p>
  <a href="https://vike.dev/renderPage"><code>renderPage(pageContextInit)</code></a> called with <code>pageContextInit.urlOriginal===${JSON.stringify(urlOriginal)}</code> which doesn't start with the Base URL <code>${baseServer}</code>.
</p>
<p>
  See <a href="https://vike.dev/base-url#setup">vike.dev/base-url#setup</a> for how to properly setup your server while using a Base URL.
</p>
<style>
  code {
    font-family: monospace;
    background-color: #eaeaea;
    padding: 3px 5px;
    border-radius: 4px;
  }
</style>
`);
    return httpResponse;
}
function createHttpResponseError(pageContext) {
    const reason = (() => {
        const errorPageId = (0, error_page_js_1.getErrorPageId)(pageContext._globalContext._pageFilesAll, pageContext._globalContext._pageConfigs);
        if (errorPageId) {
            return "the error page (https://vike.dev/error-page) couldn't be rendered (for example if an error occurred while rendering the error page)";
        }
        else {
            return 'no error page (https://vike.dev/error-page) is defined, make sure to create one';
        }
    })();
    return createHttpResponseError_(reason);
}
function createHttpResponseErrorWithoutGlobalContext() {
    return createHttpResponseError_('no error page (https://vike.dev/error-page) could be rendered');
}
function createHttpResponseError_(reason) {
    const httpResponse = createHttpResponse(500, 'text/html;charset=utf-8', [], `<p>An error occurred.</p><script>console.log(${JSON.stringify(`This HTML was generated by Vike. Vike returned this HTML because ${reason}.`)})</script>`);
    return httpResponse;
}
async function createHttpResponsePageContextJson(pageContextSerialized) {
    const httpResponse = createHttpResponse(200, 'application/json', [], pageContextSerialized, [], null);
    return httpResponse;
}
function createHttpResponseRedirect({ url, statusCode }, pageContextInit) {
    (0, assertNoInfiniteHttpRedirect_js_1.assertNoInfiniteHttpRedirect)(url, pageContextInit);
    (0, utils_js_1.assert)(url);
    (0, utils_js_1.assert)(statusCode);
    (0, utils_js_1.assert)(300 <= statusCode && statusCode <= 399);
    const headers = [['Location', url]];
    return createHttpResponse(statusCode, 'text/html;charset=utf-8', headers, 
    // For bots / programmatic crawlig: show what's going on.
    // For users: showing a blank page is probably better than a flickering text.
    `<p style="display: none">Redirecting to ${(0, utils_js_1.escapeHtml)(url)}</p><script>console.log('This HTML was generated by Vike.')</script>`);
}
function createHttpResponse(statusCode, contentType, headers, htmlRender, earlyHints = [], renderHook = null) {
    headers.push(['Content-Type', contentType]);
    (0, utils_js_1.assert)(renderHook || typeof htmlRender === 'string');
    return {
        statusCode,
        headers,
        // TO-DO/next-major-release: remove
        get contentType() {
            (0, utils_js_1.assertWarning)(false, 'pageContext.httpResponse.contentType is deprecated and will be removed in the next major release. Use pageContext.httpResponse.headers instead, see https://vike.dev/migration/0.4.134', { onlyOnce: true });
            return contentType;
        },
        earlyHints,
        get body() {
            return (0, getHttpResponseBody_js_1.getHttpResponseBody)(htmlRender, renderHook);
        },
        ...(0, getHttpResponseBody_js_1.getHttpResponseBodyStreamHandlers)(htmlRender, renderHook),
    };
}
