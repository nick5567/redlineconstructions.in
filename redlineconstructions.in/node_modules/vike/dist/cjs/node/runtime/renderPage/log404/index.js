"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.log404 = log404;
exports.getRoutesInfo = getRoutesInfo;
const noRouteMatch_js_1 = require("../../../../shared/route/noRouteMatch.js");
const utils_js_1 = require("../../utils.js");
const picocolors_1 = __importDefault(require("@brillout/picocolors"));
async function log404(pageContext) {
    const { urlPathname } = pageContext;
    const pageRoutes = pageContext._globalContext._pageRoutes;
    (0, utils_js_1.assertUsage)(pageRoutes.length > 0, 'No page found.');
    const globalContext = pageContext._globalContext;
    if (!globalContext._isProduction && !isFileRequest(urlPathname) && !pageContext.isClientSideNavigation) {
        const routesInfo = getRoutesInfo(pageRoutes);
        let msg = `URL ${picocolors_1.default.cyan(urlPathname)} ${noRouteMatch_js_1.noRouteMatch}`;
        const outro = 'See https://vike.dev/routing for more information about routing.';
        if (!routesInfo) {
            msg = `${msg}. ${picocolors_1.default.dim(outro)}`;
        }
        else {
            msg = `${msg}:\n${routesInfo}\n${outro}`;
        }
        (0, utils_js_1.assertInfo)(false, msg, { onlyOnce: false });
    }
}
function getRoutesInfo(pageRoutes) {
    const entries = pageRoutes
        .map((pageRoute) => {
        let routeStr;
        let routeTypeSrc;
        let routeDefinedBy;
        if (pageRoute.routeType === 'FILESYSTEM') {
            (0, utils_js_1.assert)(pageRoute.routeFilesystemDefinedBy);
            routeDefinedBy = pageRoute.routeFilesystemDefinedBy;
        }
        else {
            (0, utils_js_1.assert)(pageRoute.routeDefinedAtString);
            routeDefinedBy = pageRoute.routeDefinedAtString;
        }
        if (pageRoute.routeType === 'STRING') {
            routeStr = pageRoute.routeString;
            routeTypeSrc = 'Route String';
        }
        else if (pageRoute.routeType === 'FUNCTION') {
            routeStr = String(pageRoute.routeFunction);
            routeTypeSrc = 'Route Function';
        }
        else {
            routeStr = pageRoute.routeString;
            routeTypeSrc = 'Filesystem Route';
        }
        (0, utils_js_1.assert)(routeStr && routeTypeSrc && routeDefinedBy);
        return { routeStr, routeTypeSrc, routeDefinedBy };
    })
        .sort((e1, e2) => {
        if (e1.routeTypeSrc !== 'Route Function' && e2.routeTypeSrc === 'Route Function') {
            return -1;
        }
        if (e1.routeTypeSrc === 'Route Function' && e2.routeTypeSrc !== 'Route Function') {
            return 1;
        }
        return (0, utils_js_1.compareString)(e1.routeStr, e2.routeStr);
    });
    const linesContent = [
        {
            routeStr: 'ROUTE',
            routeTypeSrc: 'TYPE',
            routeDefinedBy: 'DEFINED BY',
        },
        ...entries,
    ];
    const terminalWidth = (0, utils_js_1.getTerminalWidth)() || 134;
    let width2 = Math.max(...linesContent.map(({ routeTypeSrc }) => (0, utils_js_1.stripAnsi)(routeTypeSrc).length));
    let width3 = Math.max(...linesContent.map(({ routeDefinedBy }) => (0, utils_js_1.stripAnsi)(routeDefinedBy).length));
    const width1_max = terminalWidth -
        width3 -
        width2 -
        // Total width of table border & padding
        10;
    if (width1_max < 10)
        return null;
    linesContent.forEach((lineContent) => {
        let { routeStr } = lineContent;
        if (lineContent.routeTypeSrc === 'Route Function') {
            routeStr = truncateRouteFunction(routeStr, width1_max);
            (0, utils_js_1.assert)((0, utils_js_1.stripAnsi)(routeStr).length <= width1_max);
        }
        lineContent.routeStr = routeStr;
    });
    let width1 = Math.max(...linesContent.map(({ routeStr }) => (0, utils_js_1.stripAnsi)(routeStr).length));
    if (width1 > width1_max)
        return null;
    let lines = linesContent.map(({ routeStr, routeTypeSrc, routeDefinedBy }, i) => {
        let cell1 = padEnd(routeStr, width1 + ((0, utils_js_1.stripAnsi)(routeStr).length - (0, utils_js_1.stripAnsi)(routeStr).length));
        let cell2 = padEnd(routeTypeSrc, width2);
        let cell3 = padEnd(routeDefinedBy, width3);
        const isHeader = i === 0;
        if (isHeader) {
            cell1 = picocolors_1.default.dim(cell1);
            cell2 = picocolors_1.default.dim(cell2);
            cell3 = picocolors_1.default.dim(cell3);
        }
        let line = [cell1, cell2, cell3].join(picocolors_1.default.dim(' │ '));
        line = picocolors_1.default.dim('│ ') + line + picocolors_1.default.dim(' │');
        return line;
    });
    width1 = width1 + 2;
    width2 = width2 + 2;
    width3 = width3 + 2;
    // https://en.wikipedia.org/wiki/Box-drawing_character
    lines = [
        picocolors_1.default.dim(`┌${'─'.repeat(width1)}┬${'─'.repeat(width2)}┬${'─'.repeat(width3)}┐`),
        lines[0],
        picocolors_1.default.dim(`├${'─'.repeat(width1)}┼${'─'.repeat(width2)}┼${'─'.repeat(width3)}┤`),
        ...lines.slice(1),
        picocolors_1.default.dim(`└${'─'.repeat(width1)}┴${'─'.repeat(width2)}┴${'─'.repeat(width3)}┘`),
    ];
    lines.forEach((line) => {
        (0, utils_js_1.assert)((0, utils_js_1.stripAnsi)(line).length <= terminalWidth);
    });
    return lines.join('\n');
}
function truncateRouteFunction(routeStr, lenMax) {
    routeStr = (0, utils_js_1.stripAnsi)(routeStr);
    routeStr = removeNonAscii(routeStr);
    routeStr = routeStr.split(/\s/).filter(Boolean).join(' ');
    routeStr = (0, utils_js_1.truncateString)(routeStr, lenMax);
    return routeStr;
}
/** Same as String.prototype.padEnd but with stripAnsi() */
function padEnd(str, width) {
    const padWidth = Math.max(0, width - (0, utils_js_1.stripAnsi)(str).length);
    return str + ''.padEnd(padWidth, ' ');
}
function removeNonAscii(str) {
    // https://stackoverflow.com/questions/20856197/remove-non-ascii-character-in-string/20856346#20856346
    return str.replace(/[^\x00-\x7F]/g, '');
}
function isFileRequest(urlPathname) {
    (0, utils_js_1.assert)(urlPathname.startsWith('/'));
    const paths = urlPathname.split('/');
    const lastPath = paths[paths.length - 1];
    (0, utils_js_1.assert)(typeof lastPath === 'string');
    const parts = lastPath.split('.');
    if (parts.length < 2) {
        return false;
    }
    const fileExtension = parts[parts.length - 1];
    (0, utils_js_1.assert)(typeof fileExtension === 'string');
    return /^[a-z0-9]+$/.test(fileExtension);
}
