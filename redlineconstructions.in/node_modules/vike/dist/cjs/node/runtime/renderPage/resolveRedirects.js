"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.resolveRedirects = resolveRedirects;
exports.getStaticRedirectsForPrerender = getStaticRedirectsForPrerender;
exports.resolveRouteStringRedirect = resolveRouteStringRedirect;
const assertIsNotBrowser_js_1 = require("../../../utils/assertIsNotBrowser.js");
const utils_js_1 = require("../../../shared/utils.js");
const resolveUrlPathname_js_1 = require("../../../shared/route/resolveUrlPathname.js");
const resolveRouteString_js_1 = require("../../../shared/route/resolveRouteString.js");
const picocolors_1 = __importDefault(require("@brillout/picocolors"));
(0, assertIsNotBrowser_js_1.assertIsNotBrowser)(); // Don't bloat the client
const redirectsErrPrefix = '[+redirects]';
function resolveRedirects(redirectsAll, urlPathname) {
    const redirects = merge(redirectsAll);
    for (const [urlSource, urlTarget] of Object.entries(redirects)) {
        const urlResolved = resolveRouteStringRedirect(urlSource, urlTarget, urlPathname);
        if (urlResolved)
            return urlResolved;
    }
    return null;
}
function getStaticRedirectsForPrerender(redirectsAll, showWarningUponDynamicRedirects) {
    const redirects = merge(redirectsAll);
    const redirectsStatic = {};
    for (const [urlSource, urlTarget] of Object.entries(redirects)) {
        assertRedirect(urlSource, urlTarget);
        if ((0, resolveRouteString_js_1.isStaticRouteString)(urlSource)) {
            redirectsStatic[urlSource] = urlTarget;
        }
        else if (showWarningUponDynamicRedirects) {
            (0, utils_js_1.assertWarning)(false, `Dynamic redirect ${picocolors_1.default.cyan(urlSource)} -> ${picocolors_1.default.cyan(urlTarget)} cannot be pre-rendered. You can remove this warning by setting +prerender.partial to true (https://vike.dev/prerender#partial).`, { onlyOnce: true });
        }
    }
    return redirectsStatic;
}
function resolveRouteStringRedirect(urlSource, urlTarget, urlPathname) {
    assertRedirect(urlSource, urlTarget);
    const match = (0, resolveRouteString_js_1.resolveRouteString)(urlSource, urlPathname);
    if (!match)
        return null;
    const urlResolved = (0, resolveUrlPathname_js_1.resolveUrlPathname)(urlTarget, match.routeParams);
    if (urlResolved === urlPathname)
        return null;
    (0, utils_js_1.assert)((0, utils_js_1.isUrlRedirectTarget)(urlResolved));
    return urlResolved;
}
function assertRedirect(urlSource, urlTarget) {
    (0, resolveRouteString_js_1.assertRouteString)(urlSource, `${redirectsErrPrefix} Invalid`);
    // Is allowing any protocol a safety issue? https://github.com/vikejs/vike/pull/1292#issuecomment-1828043917
    (0, utils_js_1.assertUsageUrlRedirectTarget)(urlTarget, `${redirectsErrPrefix} The URL redirection target`, true);
    assertParams(urlSource, urlTarget);
}
function assertParams(urlSource, urlTarget) {
    const routeSegments = urlTarget.split('/');
    routeSegments.forEach((routeSegment) => {
        if (routeSegment.startsWith('@') || routeSegment.startsWith('*')) {
            const segments = urlSource.split('/');
            (0, utils_js_1.assertUsage)(segments.includes(routeSegment), `${redirectsErrPrefix} The redirection source URL ${picocolors_1.default.string(urlSource)} is missing the URL parameter ${picocolors_1.default.string(routeSegment)} used by the redirection target URL ${picocolors_1.default.string(urlTarget)}`);
        }
    });
}
function merge(objs) {
    const obj = {};
    objs.forEach((e) => {
        Object.assign(obj, e);
    });
    return obj;
}
