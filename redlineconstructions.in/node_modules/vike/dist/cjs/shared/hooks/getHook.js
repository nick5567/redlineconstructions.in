"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getHookFromPageContext = getHookFromPageContext;
exports.getHookFromPageContextNew = getHookFromPageContextNew;
exports.getHookFromPageConfig = getHookFromPageConfig;
exports.getHookFromPageConfigGlobal = getHookFromPageConfigGlobal;
exports.getHookFromPageConfigGlobalCumulative = getHookFromPageConfigGlobalCumulative;
exports.getHook_setIsPrerenderering = getHook_setIsPrerenderering;
exports.getHookTimeoutDefault = getHookTimeoutDefault;
const getGlobalObject_js_1 = require("../../utils/getGlobalObject.js");
const helpers_js_1 = require("../page-configs/helpers.js");
const getConfigValueRuntime_js_1 = require("../page-configs/getConfigValueRuntime.js");
const utils_js_1 = require("../utils.js");
const picocolors_1 = __importDefault(require("@brillout/picocolors"));
const globalObject = (0, getGlobalObject_js_1.getGlobalObject)('hooks/getHook.ts', {});
function getHookFromPageContext(pageContext, hookName) {
    if (!(hookName in pageContext.exports)) {
        return null;
    }
    const { hooksTimeout } = pageContext.config;
    const hookTimeout = getHookTimeout(hooksTimeout, hookName);
    const hookFn = pageContext.exports[hookName];
    if (hookFn === null)
        return null;
    // TO-DO/eventually: use pageContext.configEntries in favor of pageContext.exportsAll once V0.4 is removed
    const file = pageContext.exportsAll[hookName][0];
    (0, utils_js_1.assert)(file.exportValue === hookFn);
    const hookFilePath = file.filePath;
    (0, utils_js_1.assert)(hookFilePath);
    return getHook(hookFn, hookName, hookFilePath, hookTimeout);
}
// TO-DO/eventually: remove getHookFromPageContext() in favor of getHookFromPageContextNew()
function getHookFromPageContextNew(hookName, pageContext) {
    const { hooksTimeout } = pageContext.config;
    const hookTimeout = getHookTimeout(hooksTimeout, hookName);
    const hooks = [];
    /* TO-DO/eventually: use pageContext.configEntries in favor of pageContext.exportsAll once V0.4 is removed
    pageContext.configEntries[hookName]?.forEach((val) => {
      const hookFn = val.configValue
      if (hookFn === null) return
      const hookFilePath = val.configDefinedByFile
    */
    pageContext.exportsAll[hookName]?.forEach((val) => {
        const hookFn = val.exportValue;
        if (hookFn === null)
            return;
        const hookFilePath = val.filePath;
        (0, utils_js_1.assert)(hookFilePath);
        hooks.push(getHook(hookFn, hookName, hookFilePath, hookTimeout));
    });
    return hooks;
}
function getHookFromPageConfig(pageConfig, hookName) {
    const configValue = (0, getConfigValueRuntime_js_1.getConfigValueRuntime)(pageConfig, hookName);
    if (!configValue?.value)
        return null;
    const { hookFn, hookFilePath } = getHookFromConfigValue(configValue);
    const hooksTimeout = (0, getConfigValueRuntime_js_1.getConfigValueRuntime)(pageConfig, 'hooksTimeout')?.value;
    const hookTimeout = getHookTimeout(hooksTimeout, hookName);
    return getHook(hookFn, hookName, hookFilePath, hookTimeout);
}
function getHookFromPageConfigGlobal(pageConfigGlobal, hookName) {
    const configValue = pageConfigGlobal.configValues[hookName];
    if (!configValue?.value)
        return null;
    const { hookFn, hookFilePath } = getHookFromConfigValue(configValue);
    const hookTimeout = getHookTimeoutGlobal(hookName);
    return getHook(hookFn, hookName, hookFilePath, hookTimeout);
}
function getHookFromPageConfigGlobalCumulative(pageConfigGlobal, hookName) {
    const configValue = pageConfigGlobal.configValues[hookName];
    if (!configValue?.value)
        return [];
    const val = configValue.value;
    (0, utils_js_1.assert)((0, utils_js_1.isArray)(val));
    return val.map((v, i) => {
        const hookFn = v;
        const hookTimeout = getHookTimeoutGlobal(hookName);
        (0, utils_js_1.assert)((0, utils_js_1.isArray)(configValue.definedAtData));
        const hookFilePath = (0, helpers_js_1.getHookFilePathToShowToUser)(configValue.definedAtData[i]);
        return getHook(hookFn, hookName, hookFilePath, hookTimeout);
    });
}
function getHookTimeoutGlobal(hookName) {
    // TO-DO/perfection: we could use the global value of configooksTimeout but it requires some non-trivial refactoring
    const hookTimeout = getHookTimeoutDefault(hookName);
    return hookTimeout;
}
function getHook(hookFn, hookName, hookFilePath, hookTimeout) {
    (0, utils_js_1.assert)(hookFilePath);
    assertHookFn(hookFn, { hookName, hookFilePath });
    const hook = { hookFn, hookName, hookFilePath, hookTimeout };
    return hook;
}
function getHookFromConfigValue(configValue) {
    const hookFn = configValue.value;
    (0, utils_js_1.assert)(hookFn);
    const hookFilePath = (0, helpers_js_1.getHookFilePathToShowToUser)(configValue.definedAtData);
    return { hookFn, hookFilePath };
}
function assertHookFn(hookFn, { hookName, hookFilePath }) {
    (0, utils_js_1.assert)(hookName && hookFilePath);
    (0, utils_js_1.assert)(!hookName.endsWith(')'));
    (0, utils_js_1.assert)(!hookFilePath.endsWith(' '));
    (0, utils_js_1.assertUsage)((0, utils_js_1.isCallable)(hookFn), `Hook ${hookName}() defined by ${hookFilePath} should be a function`);
    (0, utils_js_1.checkType)(hookFn);
}
function getHookTimeout(hooksTimeoutProvidedByUser, hookName) {
    const hooksTimeoutProvidedbyUserNormalized = getHooksTimeoutProvidedByUserNormalized(hooksTimeoutProvidedByUser);
    if (hooksTimeoutProvidedbyUserNormalized === false)
        return { error: false, warning: false };
    const providedbyUser = hooksTimeoutProvidedbyUserNormalized[hookName];
    const hookTimeout = getHookTimeoutDefault(hookName);
    if (providedbyUser?.error !== undefined)
        hookTimeout.error = providedbyUser.error;
    if (providedbyUser?.warning !== undefined)
        hookTimeout.warning = providedbyUser.warning;
    return hookTimeout;
}
// Ideally this should be called only once and at build-time (to avoid bloating the client-side bundle), but we didn't implement any mechanism to valid config values at build-time yet
function getHooksTimeoutProvidedByUserNormalized(hooksTimeoutProvidedByUser) {
    if (hooksTimeoutProvidedByUser === undefined)
        return {};
    if (hooksTimeoutProvidedByUser === false)
        return false;
    (0, utils_js_1.assertUsage)((0, utils_js_1.isObject)(hooksTimeoutProvidedByUser), `Setting ${picocolors_1.default.cyan('hooksTimeout')} should be ${picocolors_1.default.cyan('false')} or an object`);
    const hooksTimeoutProvidedByUserNormalized = {};
    Object.entries(hooksTimeoutProvidedByUser).forEach(([hookName, hookTimeoutProvidedbyUser]) => {
        if (hookTimeoutProvidedbyUser === false) {
            hooksTimeoutProvidedByUserNormalized[hookName] = { error: false, warning: false };
            return;
        }
        (0, utils_js_1.assertUsage)((0, utils_js_1.isObject)(hookTimeoutProvidedbyUser), `Setting ${picocolors_1.default.cyan(`hooksTimeout.${hookName}`)} should be ${picocolors_1.default.cyan('false')} or an object`);
        const [error, warning] = ['error', 'warning'].map((timeoutName) => {
            const timeoutVal = hookTimeoutProvidedbyUser[timeoutName];
            if (timeoutVal === undefined || timeoutVal === false)
                return timeoutVal;
            const errPrefix = `Setting ${picocolors_1.default.cyan(`hooksTimeout.${hookName}.${timeoutName}`)} should be`;
            (0, utils_js_1.assertUsage)(typeof timeoutVal === 'number', `${errPrefix} ${picocolors_1.default.cyan('false')} or a number`);
            (0, utils_js_1.assertUsage)(timeoutVal > 0, `${errPrefix} a positive number`);
            return timeoutVal;
        });
        hooksTimeoutProvidedByUserNormalized[hookName] = { error, warning };
    });
    return hooksTimeoutProvidedByUserNormalized;
}
function getHookTimeoutDefault(hookName) {
    if (hookName === 'onBeforeRoute') {
        return {
            error: 5 * 1000,
            warning: 1 * 1000,
        };
    }
    if (globalObject.isPrerendering) {
        return {
            error: 2 * 60 * 1000,
            warning: 30 * 1000,
        };
    }
    else {
        (0, utils_js_1.assert)(!hookName.toLowerCase().includes('prerender'));
    }
    return {
        error: 30 * 1000,
        warning: 4 * 1000,
    };
}
function getHook_setIsPrerenderering() {
    globalObject.isPrerendering = true;
}
