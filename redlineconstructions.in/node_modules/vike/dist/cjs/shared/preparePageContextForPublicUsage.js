"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.preparePageContextForPublicUsage = preparePageContextForPublicUsage;
exports.assertPropertyGetters = assertPropertyGetters;
const utils_js_1 = require("./utils.js");
const addIs404ToPageProps_js_1 = require("./addIs404ToPageProps.js");
const prepareGlobalContextForPublicUsage_js_1 = require("./prepareGlobalContextForPublicUsage.js");
const getProxyForPublicUsage_js_1 = require("./getProxyForPublicUsage.js");
function preparePageContextForPublicUsage(pageContext) {
    (0, utils_js_1.assert)(!pageContext._isProxyObject);
    (0, utils_js_1.assert)(!pageContext.globalContext); // pageContext.globalContext should only be available to users — Vike itself should use pageContext._globalContext instead
    (0, utils_js_1.assert)(pageContext._isOriginalObject); // ensure we preserve the original object reference
    (0, addIs404ToPageProps_js_1.addIs404ToPageProps)(pageContext);
    // TO-DO/next-major-release: remove
    if (!('_pageId' in pageContext)) {
        Object.defineProperty(pageContext, '_pageId', {
            get() {
                (0, utils_js_1.assertWarning)(false, 'pageContext._pageId has been renamed to pageContext.pageId', {
                    showStackTrace: true,
                    onlyOnce: true,
                });
                return pageContext.pageId;
            },
            enumerable: false,
        });
    }
    // For a more readable `console.log(pageContext)` output
    sortPageContext(pageContext);
    const globalContextPublic = (0, prepareGlobalContextForPublicUsage_js_1.prepareGlobalContextForPublicUsage)(pageContext._globalContext);
    const pageContextPublic = (0, getProxyForPublicUsage_js_1.getProxyForPublicUsage)(pageContext, 'pageContext', 
    // We must skip it in the client-side because of the reactivity mechanism of UI frameworks like Solid.
    // - TO-DO/soon/proxy: double check whether that's true
    true, (prop) => {
        if (prop === 'globalContext') {
            return globalContextPublic;
        }
        if (prop in globalContextPublic) {
            return globalContextPublic[prop];
        }
    });
    return pageContextPublic;
}
// Sort `pageContext` keys alphabetically, in order to make reading the `console.log(pageContext)` output easier
function sortPageContext(pageContext) {
    let descriptors = Object.getOwnPropertyDescriptors(pageContext);
    for (const key of Object.keys(pageContext))
        delete pageContext[key];
    descriptors = Object.fromEntries(Object.entries(descriptors).sort(([key1], [key2]) => (0, utils_js_1.compareString)(key1, key2)));
    Object.defineProperties(pageContext, descriptors);
}
function assertPropertyGetters(pageContext) {
    /*
    If the isPropertyGetter() assertions fail then it's most likely because Object.assign() was used instead of `objectAssign()`:
    ```js
    const PageContextUrlComputed = getPageContextUrlComputed(pageContext)
  
    // ❌ Breaks the property descriptors/getters of pageContext defined by getPageContextUrlComputed() such as pageContext.urlPathname
    Object.assign(pageContext, pageContextUrlComputed)
  
    // ❌ Also breaks property descriptors/getters
    const pageContext = { ...pageContextUrlComputed }
  
    // ✅ Preserves property descriptors/getters (see objectAssign() implementation)
    objectAssign(pageContext, pageContextUrlComputed)
    ```
    */
    ;
    [
        'urlPathname',
        // TO-DO/next-major-release: remove
        'urlParsed',
        // TO-DO/next-major-release: remove
        'url',
        // TO-DO/next-major-release: remove
        'pageExports',
    ].forEach((prop) => {
        if (pageContext.prop)
            (0, utils_js_1.assert)((0, utils_js_1.isPropertyGetter)(pageContext, prop));
    });
}
