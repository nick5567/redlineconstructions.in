"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.execHookGuard = execHookGuard;
const getHook_js_1 = require("../hooks/getHook.js");
const utils_js_1 = require("./utils.js");
const execHook_js_1 = require("../hooks/execHook.js");
const errIntro = 'The guard() hook defined by';
async function execHookGuard(pageContext, prepareForPublicUsage) {
    let hook;
    if (pageContext._globalContext._pageFilesAll.length > 0) {
        // TO-DO/next-major-release: remove
        // V0.4 design
        (0, utils_js_1.assert)(pageContext._globalContext._pageConfigs.length === 0);
        hook = findPageGuard(pageContext.pageId, pageContext._globalContext._pageFilesAll);
    }
    else {
        // V1 design
        hook = (0, getHook_js_1.getHookFromPageContext)(pageContext, 'guard');
    }
    if (!hook)
        return;
    await (0, execHook_js_1.execHookDirectSingle)(hook, pageContext, prepareForPublicUsage);
}
function findPageGuard(pageId, pageFilesAll) {
    const pageRouteFile = pageFilesAll.find((p) => p.pageId === pageId && p.fileType === '.page.route');
    if (!pageRouteFile)
        return null;
    const { filePath, fileExports } = pageRouteFile;
    (0, utils_js_1.assert)(fileExports); // loadPageRoutes() should already have been called
    const hookFn = fileExports.guard;
    if (!hookFn)
        return null;
    const hookFilePath = filePath;
    const hookTimeout = (0, getHook_js_1.getHookTimeoutDefault)('guard');
    (0, utils_js_1.assertUsage)((0, utils_js_1.isCallable)(hookFn), `${errIntro} ${hookFilePath} should be a function`);
    return { hookFn, hookName: 'guard', hookFilePath, hookTimeout };
}
