"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.route = route;
// Ensure we don't bloat runtime of Server Routing
const assertRoutingType_js_1 = require("../../utils/assertRoutingType.js");
const isBrowser_js_1 = require("../../utils/isBrowser.js");
if ((0, isBrowser_js_1.isBrowser)()) {
    (0, assertRoutingType_js_1.assertClientRouting)();
}
const utils_js_1 = require("./utils.js");
const resolvePrecedence_js_1 = require("./resolvePrecedence.js");
const resolveRouteString_js_1 = require("./resolveRouteString.js");
const resolveRouteFunction_js_1 = require("./resolveRouteFunction.js");
const execHookOnBeforeRoute_js_1 = require("./execHookOnBeforeRoute.js");
const debug_js_1 = require("./debug.js");
const picocolors_1 = __importDefault(require("@brillout/picocolors"));
// TO-DO/next-major-release: make it sync
async function route(pageContext, skipOnBeforeRouteHook) {
    (0, debug_js_1.debug)('Pages routes:', pageContext._globalContext._pageRoutes);
    const pageContextFromRoute = {};
    // onBeforeRoute()
    if (!skipOnBeforeRouteHook) {
        const pageContextFromOnBeforeRouteHook = await (0, execHookOnBeforeRoute_js_1.execHookOnBeforeRoute)(pageContext);
        if (pageContextFromOnBeforeRouteHook) {
            if (pageContextFromOnBeforeRouteHook._routingProvidedByOnBeforeRouteHook) {
                (0, utils_js_1.assert)(pageContextFromOnBeforeRouteHook.pageId);
                return pageContextFromOnBeforeRouteHook;
            }
            else {
                (0, utils_js_1.objectAssign)(pageContextFromRoute, pageContextFromOnBeforeRouteHook);
            }
        }
        // We take into account pageContext.urlLogical set by onBeforeRoute()
        (0, utils_js_1.objectAssign)(pageContext, pageContextFromOnBeforeRouteHook);
    }
    // Vike's routing
    const allPageIds = pageContext._globalContext._allPageIds;
    (0, utils_js_1.assertUsage)(allPageIds.length > 0, 'No page found. You must create at least one page.');
    (0, utils_js_1.assert)(pageContext._globalContext._pageFilesAll.length > 0 || pageContext._globalContext._pageConfigs.length > 0);
    const { urlPathname } = pageContext;
    (0, utils_js_1.assert)(urlPathname.startsWith('/'));
    const routeMatches = [];
    await Promise.all(pageContext._globalContext._pageRoutes.map(async (pageRoute) => {
        const { pageId, routeType } = pageRoute;
        // Filesystem Routing
        if (pageRoute.routeType === 'FILESYSTEM') {
            const { routeString } = pageRoute;
            const match = (0, resolveRouteString_js_1.resolveRouteString)(routeString, urlPathname);
            if (match) {
                const { routeParams } = match;
                routeMatches.push({ pageId, routeParams, routeString, routeType });
            }
            return;
        }
        // Route String defined in `.page.route.js`
        if (pageRoute.routeType === 'STRING') {
            const { routeString } = pageRoute;
            const match = (0, resolveRouteString_js_1.resolveRouteString)(routeString, urlPathname);
            if (match) {
                const { routeParams } = match;
                (0, utils_js_1.assert)(routeType === 'STRING');
                routeMatches.push({
                    pageId,
                    routeString,
                    routeParams,
                    routeType,
                });
            }
            return;
        }
        // Route Function defined in `.page.route.js`
        if (pageRoute.routeType === 'FUNCTION') {
            const { routeFunction, routeFunctionFilePath } = pageRoute;
            const match = await (0, resolveRouteFunction_js_1.resolveRouteFunction)(routeFunction, pageContext, routeFunctionFilePath);
            if (match) {
                const { routeParams, precedence } = match;
                routeMatches.push({ pageId, precedence, routeParams, routeType });
            }
            return;
        }
        (0, utils_js_1.assert)(false);
    }));
    (0, resolvePrecedence_js_1.resolvePrecedence)(routeMatches);
    const winner = routeMatches[0] ?? null;
    (0, debug_js_1.debug)(`Route matches for URL ${picocolors_1.default.cyan(urlPathname)} (in precedence order):`, routeMatches);
    (0, utils_js_1.objectAssign)(pageContextFromRoute, { _debugRouteMatches: routeMatches });
    // For vite-plugin-vercel https://github.com/magne4000/vite-plugin-vercel/blob/main/packages/vike-integration/vike.ts#L173
    (0, utils_js_1.objectAssign)(pageContextFromRoute, { _routeMatch: winner });
    if (!winner) {
        (0, utils_js_1.objectAssign)(pageContextFromRoute, {
            pageId: null,
            routeParams: {},
        });
        return pageContextFromRoute;
    }
    {
        const { routeParams } = winner;
        (0, utils_js_1.assert)((0, utils_js_1.isPlainObject)(routeParams));
        (0, utils_js_1.objectAssign)(pageContextFromRoute, {
            pageId: winner.pageId,
            routeParams: winner.routeParams,
        });
    }
    return pageContextFromRoute;
}
