"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.resolvePrecedence = resolvePrecedence;
// export type { RouteMatch }
const resolveRouteString_js_1 = require("./resolveRouteString.js");
const utils_js_1 = require("./utils.js");
const utils_js_2 = require("./utils.js");
const resolveRouteString_js_2 = require("./resolveRouteString.js");
// See https://vike.dev/route-function#precedence
function resolvePrecedence(routeMatches) {
    // prettier-ignore
    // biome-ignore format:
    routeMatches
        .sort(sortMatches)
        .sort((0, utils_js_2.makeFirst)((routeMatch) => routeMatch.routeType === 'FUNCTION' && !!routeMatch.precedence && routeMatch.precedence < 0))
        .sort((0, utils_js_2.makeFirst)((routeMatch) => routeMatch.routeType === 'STRING' && (0, resolveRouteString_js_2.isStaticRouteString)(routeMatch.routeString) === false))
        .sort((0, utils_js_2.makeFirst)((routeMatch) => routeMatch.routeType === 'FUNCTION' && !routeMatch.precedence))
        .sort((0, utils_js_2.makeFirst)((routeMatch) => routeMatch.routeType === 'STRING' && (0, resolveRouteString_js_2.isStaticRouteString)(routeMatch.routeString) === true))
        .sort((0, utils_js_2.makeFirst)((routeMatch) => routeMatch.routeType === 'FILESYSTEM'))
        .sort((0, utils_js_2.makeFirst)((routeMatch) => routeMatch.routeType === 'FUNCTION' && !!routeMatch.precedence && routeMatch.precedence > 0));
}
// -1 => routeMatch1 higher precedence
// +1 => routeMatch2 higher precedence
function sortMatches(routeMatch1, routeMatch2) {
    {
        const precedence1 = routeMatch1.precedence ?? 0;
        const precedence2 = routeMatch2.precedence ?? 0;
        if (precedence1 !== precedence2) {
            return precedence1 > precedence2 ? -1 : 1;
        }
    }
    if (!routeMatch2.routeString) {
        return 0;
    }
    if (!routeMatch1.routeString) {
        return 0;
    }
    /* DEBUG
    console.log('routeMatch1.routeString', routeMatch1.routeString)
    console.log('routeMatch2.routeString', routeMatch2.routeString)
    console.log('parseRouteString(routeMatch1.routeString)', parseRouteString(routeMatch1.routeString))
    console.log('parseRouteString(routeMatch2.routeString)', parseRouteString(routeMatch2.routeString))
    //*/
    // Return route with highest number of static path segments at beginning first
    {
        const getValue = (routeString) => (0, resolveRouteString_js_1.analyzeRouteString)(routeString).numberOfStaticPartsBeginning;
        const result = (0, utils_js_1.higherFirst)(getValue)(routeMatch1.routeString, routeMatch2.routeString);
        if (result !== 0) {
            /* DEBUG
            console.log('analyzeRouteString(routeMatch1.routeString).numberOfStaticPartsBeginning', getValue(routeMatch1.routeString))
            console.log('analyzeRouteString(routeMatch2.routeString).numberOfStaticPartsBeginning', getValue(routeMatch2.routeString))
            //*/
            return result;
        }
    }
    // Return route with highest number of static path segments in total first
    {
        const getValue = (routeString) => (0, resolveRouteString_js_1.analyzeRouteString)(routeString).numberOfStaticParts;
        const result = (0, utils_js_1.higherFirst)(getValue)(routeMatch1.routeString, routeMatch2.routeString);
        if (result !== 0) {
            /* DEBUG
            console.log('analyzeRouteString(routeMatch1.routeString).numberOfStaticParts', getValue(routeMatch1.routeString))
            console.log('analyzeRouteString(routeMatch2.routeString).numberOfStaticParts', getValue(routeMatch2.routeString))
            //*/
            return result;
        }
    }
    // Return route with least amount of globs first
    {
        const getValue = (routeString) => (0, resolveRouteString_js_1.analyzeRouteString)(routeString).numberOfGlobs;
        const result = (0, utils_js_1.lowerFirst)(getValue)(routeMatch1.routeString, routeMatch2.routeString);
        if (result !== 0) {
            /* DEBUG
            console.log('analyzeRouteString(routeMatch1.routeString).numberOfGlobs', getValue(routeMatch1.routeString))
            console.log('analyzeRouteString(routeMatch2.routeString).numberOfGlobs', getValue(routeMatch2.routeString))
            //*/
            return result;
        }
    }
    // Return route with highest number of parameters first
    {
        const getValue = (routeString) => (0, resolveRouteString_js_1.analyzeRouteString)(routeString).numberOfParams;
        const result = (0, utils_js_1.higherFirst)(getValue)(routeMatch1.routeString, routeMatch2.routeString);
        if (result !== 0) {
            /* DEBUG
            console.log('analyzeRouteString(routeMatch1.routeString).numberOfParams', getValue(routeMatch1.routeString))
            console.log('analyzeRouteString(routeMatch2.routeString).numberOfParams', getValue(routeMatch2.routeString))
            //*/
            return result;
        }
    }
    return 0;
}
