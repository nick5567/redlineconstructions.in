"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.execHookOnBeforeRoute = execHookOnBeforeRoute;
const assertPageContextProvidedByUser_js_1 = require("../assertPageContextProvidedByUser.js");
const utils_js_1 = require("./utils.js");
const resolveRouteFunction_js_1 = require("./resolveRouteFunction.js");
const picocolors_1 = __importDefault(require("@brillout/picocolors"));
const execHook_js_1 = require("../hooks/execHook.js");
const preparePageContextForPublicUsage_js_1 = require("../preparePageContextForPublicUsage.js");
async function execHookOnBeforeRoute(pageContext) {
    const pageContextFromOnBeforeRouteHook = {};
    if (!pageContext._globalContext._onBeforeRouteHook)
        return null;
    const pageContextFromHook = await getPageContextFromHook(pageContext._globalContext._onBeforeRouteHook, pageContext);
    if (pageContextFromHook) {
        (0, utils_js_1.objectAssign)(pageContextFromOnBeforeRouteHook, pageContextFromHook);
        if ((0, utils_js_1.hasProp)(pageContextFromOnBeforeRouteHook, 'pageId', 'string') ||
            (0, utils_js_1.hasProp)(pageContextFromOnBeforeRouteHook, 'pageId', 'null')) {
            // We bypass Vike's routing
            if (!(0, utils_js_1.hasProp)(pageContextFromOnBeforeRouteHook, 'routeParams')) {
                (0, utils_js_1.objectAssign)(pageContextFromOnBeforeRouteHook, { routeParams: {} });
            }
            else {
                (0, utils_js_1.assert)((0, utils_js_1.hasProp)(pageContextFromOnBeforeRouteHook, 'routeParams', 'object'));
            }
            (0, utils_js_1.objectAssign)(pageContextFromOnBeforeRouteHook, {
                _routingProvidedByOnBeforeRouteHook: true,
                _debugRouteMatches: 'CUSTOM_ROUTING',
            });
            return pageContextFromOnBeforeRouteHook;
        }
    }
    (0, utils_js_1.objectAssign)(pageContextFromOnBeforeRouteHook, {
        _routingProvidedByOnBeforeRouteHook: false,
    });
    return pageContextFromOnBeforeRouteHook;
}
async function getPageContextFromHook(onBeforeRouteHook, pageContext) {
    let { hookReturn } = (0, execHook_js_1.execHookDirectSync)(onBeforeRouteHook, pageContext, preparePageContextForPublicUsage_js_1.preparePageContextForPublicUsage);
    (0, resolveRouteFunction_js_1.assertSyncRouting)(hookReturn, `The onBeforeRoute() hook ${onBeforeRouteHook.hookFilePath}`);
    // TO-DO/next-major-release: make execHookOnBeforeRoute() and route() sync
    hookReturn = await hookReturn;
    const errPrefix = `The onBeforeRoute() hook defined by ${onBeforeRouteHook.hookFilePath}`;
    (0, utils_js_1.assertUsage)(hookReturn === null ||
        hookReturn === undefined ||
        ((0, utils_js_1.isObjectWithKeys)(hookReturn, ['pageContext']) && (0, utils_js_1.hasProp)(hookReturn, 'pageContext')), `${errPrefix} should return ${picocolors_1.default.cyan('null')}, ${picocolors_1.default.cyan('undefined')}, or a plain JavaScript object ${picocolors_1.default.cyan('{ pageContext: { /* ... */ } }')}`);
    if (hookReturn === null || hookReturn === undefined) {
        return null;
    }
    (0, utils_js_1.assertUsage)((0, utils_js_1.hasProp)(hookReturn, 'pageContext', 'object'), `${errPrefix} returned ${picocolors_1.default.cyan('{ pageContext }')} but pageContext should be a plain JavaScript object.`);
    if ((0, utils_js_1.hasProp)(hookReturn.pageContext, 'pageId') && !(0, utils_js_1.hasProp)(hookReturn.pageContext, 'pageId', 'null')) {
        const errPrefix2 = `${errPrefix} returned ${picocolors_1.default.cyan('{ pageContext: { pageId } }')} but ${picocolors_1.default.cyan('pageId')} should be`;
        (0, utils_js_1.assertUsage)((0, utils_js_1.hasProp)(hookReturn.pageContext, 'pageId', 'string'), `${errPrefix2} a string or null`);
        (0, utils_js_1.assertUsage)(pageContext._globalContext._allPageIds.includes(hookReturn.pageContext.pageId), `${errPrefix2} ${(0, utils_js_1.joinEnglish)(pageContext._globalContext._allPageIds.map((s) => picocolors_1.default.cyan(s)), 'or')}`);
    }
    if ((0, utils_js_1.hasProp)(hookReturn.pageContext, 'routeParams')) {
        (0, resolveRouteFunction_js_1.assertRouteParams)(hookReturn.pageContext, `${errPrefix} returned ${picocolors_1.default.cyan('{ pageContext: { routeParams } }')} but routeParams should`);
    }
    const deprecatedReturn = (prop) => `${errPrefix} returned ${picocolors_1.default.cyan(`{ pageContext: { ${prop} } }`)} which is deprecated. Return ${picocolors_1.default.cyan('{ pageContext: { urlLogical } }')} instead.`;
    if ((0, utils_js_1.hasProp)(hookReturn.pageContext, 'url')) {
        (0, utils_js_1.assertWarning)(false, deprecatedReturn('url'), { onlyOnce: true });
        hookReturn.pageContext.urlLogical = hookReturn.pageContext.url;
        delete hookReturn.pageContext.url;
    }
    if ((0, utils_js_1.hasProp)(hookReturn.pageContext, 'urlOriginal')) {
        (0, utils_js_1.assertWarning)(false, deprecatedReturn('urlOriginal'), { onlyOnce: true });
        hookReturn.pageContext.urlLogical = hookReturn.pageContext.urlOriginal;
        delete hookReturn.pageContext.urlOriginal;
    }
    if ((0, utils_js_1.hasProp)(hookReturn.pageContext, 'urlLogical')) {
        (0, utils_js_1.assertUsageUrlPathnameAbsolute)(
        // We skip validation and type-cast instead of assertUsage() in order to save client-side KBs
        hookReturn.pageContext.urlLogical, `${errPrefix} returned ${picocolors_1.default.cyan('{ pageContext: { urlLogical } }')} and ${picocolors_1.default.cyan('urlLogical')}`);
    }
    (0, assertPageContextProvidedByUser_js_1.assertPageContextProvidedByUser)(hookReturn.pageContext, {
        hookFilePath: onBeforeRouteHook.hookFilePath,
        hookName: 'onBeforeRoute',
    });
    const pageContextAddendumHook = {};
    (0, utils_js_1.objectAssign)(pageContextAddendumHook, hookReturn.pageContext);
    return pageContextAddendumHook;
}
